/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was generated by "go run gen/main.go > gen.go". Do not edit
// directly.

package cloud

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	"github.com/bowei/gce-gen/pkg/cloud/meta"
	"google.golang.org/api/googleapi"

	alpha "google.golang.org/api/compute/v0.alpha"
	beta "google.golang.org/api/compute/v0.beta"
	ga "google.golang.org/api/compute/v1"
)

// Cloud is an interface for the GCE compute API.
type Cloud interface {
	Addresses() Addresses
	AlphaAddresses() AlphaAddresses
	BetaAddresses() BetaAddresses
	GlobalAddresses() GlobalAddresses
	BackendServices() BackendServices
	AlphaBackendServices() AlphaBackendServices
	AlphaRegionBackendServices() AlphaRegionBackendServices
	Disks() Disks
	AlphaDisks() AlphaDisks
	AlphaRegionDisks() AlphaRegionDisks
	Firewalls() Firewalls
	ForwardingRules() ForwardingRules
	AlphaForwardingRules() AlphaForwardingRules
	GlobalForwardingRules() GlobalForwardingRules
	HealthChecks() HealthChecks
	AlphaHealthChecks() AlphaHealthChecks
	HttpHealthChecks() HttpHealthChecks
	HttpsHealthChecks() HttpsHealthChecks
	InstanceGroups() InstanceGroups
	Instances() Instances
	BetaInstances() BetaInstances
	AlphaInstances() AlphaInstances
	AlphaNetworkEndpointGroups() AlphaNetworkEndpointGroups
	Regions() Regions
	Routes() Routes
	SslCertificates() SslCertificates
	TargetHttpProxies() TargetHttpProxies
	TargetHttpsProxies() TargetHttpsProxies
	TargetPools() TargetPools
	UrlMaps() UrlMaps
	Zones() Zones
}

// NewMockGCE returns a new mock for GCE.
func NewMockGCE() *MockGCE {
	mock := &MockGCE{
		MockAddresses:                  NewMockAddresses(),
		MockAlphaAddresses:             NewMockAlphaAddresses(),
		MockBetaAddresses:              NewMockBetaAddresses(),
		MockGlobalAddresses:            NewMockGlobalAddresses(),
		MockBackendServices:            NewMockBackendServices(),
		MockAlphaBackendServices:       NewMockAlphaBackendServices(),
		MockAlphaRegionBackendServices: NewMockAlphaRegionBackendServices(),
		MockDisks:                      NewMockDisks(),
		MockAlphaDisks:                 NewMockAlphaDisks(),
		MockAlphaRegionDisks:           NewMockAlphaRegionDisks(),
		MockFirewalls:                  NewMockFirewalls(),
		MockForwardingRules:            NewMockForwardingRules(),
		MockAlphaForwardingRules:       NewMockAlphaForwardingRules(),
		MockGlobalForwardingRules:      NewMockGlobalForwardingRules(),
		MockHealthChecks:               NewMockHealthChecks(),
		MockAlphaHealthChecks:          NewMockAlphaHealthChecks(),
		MockHttpHealthChecks:           NewMockHttpHealthChecks(),
		MockHttpsHealthChecks:          NewMockHttpsHealthChecks(),
		MockInstanceGroups:             NewMockInstanceGroups(),
		MockInstances:                  NewMockInstances(),
		MockBetaInstances:              NewMockBetaInstances(),
		MockAlphaInstances:             NewMockAlphaInstances(),
		MockAlphaNetworkEndpointGroups: NewMockAlphaNetworkEndpointGroups(),
		MockRegions:                    NewMockRegions(),
		MockRoutes:                     NewMockRoutes(),
		MockSslCertificates:            NewMockSslCertificates(),
		MockTargetHttpProxies:          NewMockTargetHttpProxies(),
		MockTargetHttpsProxies:         NewMockTargetHttpsProxies(),
		MockTargetPools:                NewMockTargetPools(),
		MockUrlMaps:                    NewMockUrlMaps(),
		MockZones:                      NewMockZones(),
	}
	return mock
}

// MockGCE implements Cloud.
var _ Cloud = (*MockGCE)(nil)

// MockGCE is the mock for the compute API.
type MockGCE struct {
	MockAddresses                  *MockAddresses
	MockAlphaAddresses             *MockAlphaAddresses
	MockBetaAddresses              *MockBetaAddresses
	MockGlobalAddresses            *MockGlobalAddresses
	MockBackendServices            *MockBackendServices
	MockAlphaBackendServices       *MockAlphaBackendServices
	MockAlphaRegionBackendServices *MockAlphaRegionBackendServices
	MockDisks                      *MockDisks
	MockAlphaDisks                 *MockAlphaDisks
	MockAlphaRegionDisks           *MockAlphaRegionDisks
	MockFirewalls                  *MockFirewalls
	MockForwardingRules            *MockForwardingRules
	MockAlphaForwardingRules       *MockAlphaForwardingRules
	MockGlobalForwardingRules      *MockGlobalForwardingRules
	MockHealthChecks               *MockHealthChecks
	MockAlphaHealthChecks          *MockAlphaHealthChecks
	MockHttpHealthChecks           *MockHttpHealthChecks
	MockHttpsHealthChecks          *MockHttpsHealthChecks
	MockInstanceGroups             *MockInstanceGroups
	MockInstances                  *MockInstances
	MockBetaInstances              *MockBetaInstances
	MockAlphaInstances             *MockAlphaInstances
	MockAlphaNetworkEndpointGroups *MockAlphaNetworkEndpointGroups
	MockRegions                    *MockRegions
	MockRoutes                     *MockRoutes
	MockSslCertificates            *MockSslCertificates
	MockTargetHttpProxies          *MockTargetHttpProxies
	MockTargetHttpsProxies         *MockTargetHttpsProxies
	MockTargetPools                *MockTargetPools
	MockUrlMaps                    *MockUrlMaps
	MockZones                      *MockZones
}

func (mock *MockGCE) Addresses() Addresses {
	return mock.MockAddresses
}

func (mock *MockGCE) AlphaAddresses() AlphaAddresses {
	return mock.MockAlphaAddresses
}

func (mock *MockGCE) BetaAddresses() BetaAddresses {
	return mock.MockBetaAddresses
}

func (mock *MockGCE) GlobalAddresses() GlobalAddresses {
	return mock.MockGlobalAddresses
}

func (mock *MockGCE) BackendServices() BackendServices {
	return mock.MockBackendServices
}

func (mock *MockGCE) AlphaBackendServices() AlphaBackendServices {
	return mock.MockAlphaBackendServices
}

func (mock *MockGCE) AlphaRegionBackendServices() AlphaRegionBackendServices {
	return mock.MockAlphaRegionBackendServices
}

func (mock *MockGCE) Disks() Disks {
	return mock.MockDisks
}

func (mock *MockGCE) AlphaDisks() AlphaDisks {
	return mock.MockAlphaDisks
}

func (mock *MockGCE) AlphaRegionDisks() AlphaRegionDisks {
	return mock.MockAlphaRegionDisks
}

func (mock *MockGCE) Firewalls() Firewalls {
	return mock.MockFirewalls
}

func (mock *MockGCE) ForwardingRules() ForwardingRules {
	return mock.MockForwardingRules
}

func (mock *MockGCE) AlphaForwardingRules() AlphaForwardingRules {
	return mock.MockAlphaForwardingRules
}

func (mock *MockGCE) GlobalForwardingRules() GlobalForwardingRules {
	return mock.MockGlobalForwardingRules
}

func (mock *MockGCE) HealthChecks() HealthChecks {
	return mock.MockHealthChecks
}

func (mock *MockGCE) AlphaHealthChecks() AlphaHealthChecks {
	return mock.MockAlphaHealthChecks
}

func (mock *MockGCE) HttpHealthChecks() HttpHealthChecks {
	return mock.MockHttpHealthChecks
}

func (mock *MockGCE) HttpsHealthChecks() HttpsHealthChecks {
	return mock.MockHttpsHealthChecks
}

func (mock *MockGCE) InstanceGroups() InstanceGroups {
	return mock.MockInstanceGroups
}

func (mock *MockGCE) Instances() Instances {
	return mock.MockInstances
}

func (mock *MockGCE) BetaInstances() BetaInstances {
	return mock.MockBetaInstances
}

func (mock *MockGCE) AlphaInstances() AlphaInstances {
	return mock.MockAlphaInstances
}

func (mock *MockGCE) AlphaNetworkEndpointGroups() AlphaNetworkEndpointGroups {
	return mock.MockAlphaNetworkEndpointGroups
}

func (mock *MockGCE) Regions() Regions {
	return mock.MockRegions
}

func (mock *MockGCE) Routes() Routes {
	return mock.MockRoutes
}

func (mock *MockGCE) SslCertificates() SslCertificates {
	return mock.MockSslCertificates
}

func (mock *MockGCE) TargetHttpProxies() TargetHttpProxies {
	return mock.MockTargetHttpProxies
}

func (mock *MockGCE) TargetHttpsProxies() TargetHttpsProxies {
	return mock.MockTargetHttpsProxies
}

func (mock *MockGCE) TargetPools() TargetPools {
	return mock.MockTargetPools
}

func (mock *MockGCE) UrlMaps() UrlMaps {
	return mock.MockUrlMaps
}

func (mock *MockGCE) Zones() Zones {
	return mock.MockZones
}

// NewGCE returns a GCE.
func NewGCE(s *Service) *GCE {
	g := &GCE{
		gceAddresses:                  &GCEAddresses{s},
		gceAlphaAddresses:             &GCEAlphaAddresses{s},
		gceBetaAddresses:              &GCEBetaAddresses{s},
		gceGlobalAddresses:            &GCEGlobalAddresses{s},
		gceBackendServices:            &GCEBackendServices{s},
		gceAlphaBackendServices:       &GCEAlphaBackendServices{s},
		gceAlphaRegionBackendServices: &GCEAlphaRegionBackendServices{s},
		gceDisks:                      &GCEDisks{s},
		gceAlphaDisks:                 &GCEAlphaDisks{s},
		gceAlphaRegionDisks:           &GCEAlphaRegionDisks{s},
		gceFirewalls:                  &GCEFirewalls{s},
		gceForwardingRules:            &GCEForwardingRules{s},
		gceAlphaForwardingRules:       &GCEAlphaForwardingRules{s},
		gceGlobalForwardingRules:      &GCEGlobalForwardingRules{s},
		gceHealthChecks:               &GCEHealthChecks{s},
		gceAlphaHealthChecks:          &GCEAlphaHealthChecks{s},
		gceHttpHealthChecks:           &GCEHttpHealthChecks{s},
		gceHttpsHealthChecks:          &GCEHttpsHealthChecks{s},
		gceInstanceGroups:             &GCEInstanceGroups{s},
		gceInstances:                  &GCEInstances{s},
		gceBetaInstances:              &GCEBetaInstances{s},
		gceAlphaInstances:             &GCEAlphaInstances{s},
		gceAlphaNetworkEndpointGroups: &GCEAlphaNetworkEndpointGroups{s},
		gceRegions:                    &GCERegions{s},
		gceRoutes:                     &GCERoutes{s},
		gceSslCertificates:            &GCESslCertificates{s},
		gceTargetHttpProxies:          &GCETargetHttpProxies{s},
		gceTargetHttpsProxies:         &GCETargetHttpsProxies{s},
		gceTargetPools:                &GCETargetPools{s},
		gceUrlMaps:                    &GCEUrlMaps{s},
		gceZones:                      &GCEZones{s},
	}
	return g
}

// GCE implements Cloud.
var _ Cloud = (*GCE)(nil)

// GCE is the golang adapter for the compute APIs.
type GCE struct {
	gceAddresses                  *GCEAddresses
	gceAlphaAddresses             *GCEAlphaAddresses
	gceBetaAddresses              *GCEBetaAddresses
	gceGlobalAddresses            *GCEGlobalAddresses
	gceBackendServices            *GCEBackendServices
	gceAlphaBackendServices       *GCEAlphaBackendServices
	gceAlphaRegionBackendServices *GCEAlphaRegionBackendServices
	gceDisks                      *GCEDisks
	gceAlphaDisks                 *GCEAlphaDisks
	gceAlphaRegionDisks           *GCEAlphaRegionDisks
	gceFirewalls                  *GCEFirewalls
	gceForwardingRules            *GCEForwardingRules
	gceAlphaForwardingRules       *GCEAlphaForwardingRules
	gceGlobalForwardingRules      *GCEGlobalForwardingRules
	gceHealthChecks               *GCEHealthChecks
	gceAlphaHealthChecks          *GCEAlphaHealthChecks
	gceHttpHealthChecks           *GCEHttpHealthChecks
	gceHttpsHealthChecks          *GCEHttpsHealthChecks
	gceInstanceGroups             *GCEInstanceGroups
	gceInstances                  *GCEInstances
	gceBetaInstances              *GCEBetaInstances
	gceAlphaInstances             *GCEAlphaInstances
	gceAlphaNetworkEndpointGroups *GCEAlphaNetworkEndpointGroups
	gceRegions                    *GCERegions
	gceRoutes                     *GCERoutes
	gceSslCertificates            *GCESslCertificates
	gceTargetHttpProxies          *GCETargetHttpProxies
	gceTargetHttpsProxies         *GCETargetHttpsProxies
	gceTargetPools                *GCETargetPools
	gceUrlMaps                    *GCEUrlMaps
	gceZones                      *GCEZones
}

func (gce *GCE) Addresses() Addresses {
	return gce.gceAddresses
}

func (gce *GCE) AlphaAddresses() AlphaAddresses {
	return gce.gceAlphaAddresses
}

func (gce *GCE) BetaAddresses() BetaAddresses {
	return gce.gceBetaAddresses
}

func (gce *GCE) GlobalAddresses() GlobalAddresses {
	return gce.gceGlobalAddresses
}

func (gce *GCE) BackendServices() BackendServices {
	return gce.gceBackendServices
}

func (gce *GCE) AlphaBackendServices() AlphaBackendServices {
	return gce.gceAlphaBackendServices
}

func (gce *GCE) AlphaRegionBackendServices() AlphaRegionBackendServices {
	return gce.gceAlphaRegionBackendServices
}

func (gce *GCE) Disks() Disks {
	return gce.gceDisks
}

func (gce *GCE) AlphaDisks() AlphaDisks {
	return gce.gceAlphaDisks
}

func (gce *GCE) AlphaRegionDisks() AlphaRegionDisks {
	return gce.gceAlphaRegionDisks
}

func (gce *GCE) Firewalls() Firewalls {
	return gce.gceFirewalls
}

func (gce *GCE) ForwardingRules() ForwardingRules {
	return gce.gceForwardingRules
}

func (gce *GCE) AlphaForwardingRules() AlphaForwardingRules {
	return gce.gceAlphaForwardingRules
}

func (gce *GCE) GlobalForwardingRules() GlobalForwardingRules {
	return gce.gceGlobalForwardingRules
}

func (gce *GCE) HealthChecks() HealthChecks {
	return gce.gceHealthChecks
}

func (gce *GCE) AlphaHealthChecks() AlphaHealthChecks {
	return gce.gceAlphaHealthChecks
}

func (gce *GCE) HttpHealthChecks() HttpHealthChecks {
	return gce.gceHttpHealthChecks
}

func (gce *GCE) HttpsHealthChecks() HttpsHealthChecks {
	return gce.gceHttpsHealthChecks
}

func (gce *GCE) InstanceGroups() InstanceGroups {
	return gce.gceInstanceGroups
}

func (gce *GCE) Instances() Instances {
	return gce.gceInstances
}

func (gce *GCE) BetaInstances() BetaInstances {
	return gce.gceBetaInstances
}

func (gce *GCE) AlphaInstances() AlphaInstances {
	return gce.gceAlphaInstances
}

func (gce *GCE) AlphaNetworkEndpointGroups() AlphaNetworkEndpointGroups {
	return gce.gceAlphaNetworkEndpointGroups
}

func (gce *GCE) Regions() Regions {
	return gce.gceRegions
}

func (gce *GCE) Routes() Routes {
	return gce.gceRoutes
}

func (gce *GCE) SslCertificates() SslCertificates {
	return gce.gceSslCertificates
}

func (gce *GCE) TargetHttpProxies() TargetHttpProxies {
	return gce.gceTargetHttpProxies
}

func (gce *GCE) TargetHttpsProxies() TargetHttpsProxies {
	return gce.gceTargetHttpsProxies
}

func (gce *GCE) TargetPools() TargetPools {
	return gce.gceTargetPools
}

func (gce *GCE) UrlMaps() UrlMaps {
	return gce.gceUrlMaps
}

func (gce *GCE) Zones() Zones {
	return gce.gceZones
}

// Addresses is an interface that allows for mocking of Addresses.
type Addresses interface {
	Get(ctx context.Context, key meta.Key) (*ga.Address, error)
	List(ctx context.Context, region string) ([]*ga.Address, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.Address) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockAddresses returns a new mock for Addresses.
func NewMockAddresses() *MockAddresses {
	mock := &MockAddresses{
		Objects:     map[meta.Key]*ga.Address{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAddresses is the mock for Addresses.
type MockAddresses struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Address

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAddresses, ctx context.Context, key meta.Key) (bool, *ga.Address, error)
	ListHook   func(m *MockAddresses, ctx context.Context) (bool, []*ga.Address, error)
	InsertHook func(m *MockAddresses, ctx context.Context, key meta.Key, obj *ga.Address) (bool, error)
	DeleteHook func(m *MockAddresses, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAddresses) Get(ctx context.Context, key meta.Key) (*ga.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAddresses %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockAddresses) List(ctx context.Context, region string) ([]*ga.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Address
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAddresses) Insert(ctx context.Context, key meta.Key, obj *ga.Address) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAddresses %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAddresses) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAddresses %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEAddresses is a simplifying adapter for the GCE Addresses.
type GCEAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEAddresses) Get(ctx context.Context, key meta.Key) (*ga.Address, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Addresses")

	call := g.s.GA.Addresses.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Address objects.
func (g *GCEAddresses) List(ctx context.Context, region string) ([]*ga.Address, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Addresses")

	call := g.s.GA.Addresses.List(projectID, region)

	var all []*ga.Address
	f := func(l *ga.AddressList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEAddresses) Insert(ctx context.Context, key meta.Key, obj *ga.Address) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Addresses")
	obj.Name = key.Name

	call := g.s.GA.Addresses.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Address referenced by key.
func (g *GCEAddresses) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Addresses")

	call := g.s.GA.Addresses.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// AlphaAddresses is an interface that allows for mocking of Addresses.
type AlphaAddresses interface {
	Get(ctx context.Context, key meta.Key) (*alpha.Address, error)
	List(ctx context.Context, region string) ([]*alpha.Address, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.Address) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockAlphaAddresses returns a new mock for Addresses.
func NewMockAlphaAddresses() *MockAlphaAddresses {
	mock := &MockAlphaAddresses{
		Objects:     map[meta.Key]*alpha.Address{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaAddresses is the mock for Addresses.
type MockAlphaAddresses struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.Address

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaAddresses, ctx context.Context, key meta.Key) (bool, *alpha.Address, error)
	ListHook   func(m *MockAlphaAddresses, ctx context.Context) (bool, []*alpha.Address, error)
	InsertHook func(m *MockAlphaAddresses, ctx context.Context, key meta.Key, obj *alpha.Address) (bool, error)
	DeleteHook func(m *MockAlphaAddresses, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaAddresses) Get(ctx context.Context, key meta.Key) (*alpha.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaAddresses %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaAddresses) List(ctx context.Context, region string) ([]*alpha.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.Address
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaAddresses) Insert(ctx context.Context, key meta.Key, obj *alpha.Address) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaAddresses %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaAddresses) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaAddresses %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEAlphaAddresses is a simplifying adapter for the GCE Addresses.
type GCEAlphaAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEAlphaAddresses) Get(ctx context.Context, key meta.Key) (*alpha.Address, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Addresses")

	call := g.s.Alpha.Addresses.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Address objects.
func (g *GCEAlphaAddresses) List(ctx context.Context, region string) ([]*alpha.Address, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Addresses")

	call := g.s.Alpha.Addresses.List(projectID, region)

	var all []*alpha.Address
	f := func(l *alpha.AddressList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEAlphaAddresses) Insert(ctx context.Context, key meta.Key, obj *alpha.Address) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Addresses")
	obj.Name = key.Name

	call := g.s.Alpha.Addresses.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Address referenced by key.
func (g *GCEAlphaAddresses) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Addresses")

	call := g.s.Alpha.Addresses.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// BetaAddresses is an interface that allows for mocking of Addresses.
type BetaAddresses interface {
	Get(ctx context.Context, key meta.Key) (*beta.Address, error)
	List(ctx context.Context, region string) ([]*beta.Address, error)
	Insert(ctx context.Context, key meta.Key, obj *beta.Address) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockBetaAddresses returns a new mock for Addresses.
func NewMockBetaAddresses() *MockBetaAddresses {
	mock := &MockBetaAddresses{
		Objects:     map[meta.Key]*beta.Address{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaAddresses is the mock for Addresses.
type MockBetaAddresses struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*beta.Address

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockBetaAddresses, ctx context.Context, key meta.Key) (bool, *beta.Address, error)
	ListHook   func(m *MockBetaAddresses, ctx context.Context) (bool, []*beta.Address, error)
	InsertHook func(m *MockBetaAddresses, ctx context.Context, key meta.Key, obj *beta.Address) (bool, error)
	DeleteHook func(m *MockBetaAddresses, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaAddresses) Get(ctx context.Context, key meta.Key) (*beta.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaAddresses %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockBetaAddresses) List(ctx context.Context, region string) ([]*beta.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*beta.Address
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaAddresses) Insert(ctx context.Context, key meta.Key, obj *beta.Address) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaAddresses %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaAddresses) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaAddresses %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEBetaAddresses is a simplifying adapter for the GCE Addresses.
type GCEBetaAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEBetaAddresses) Get(ctx context.Context, key meta.Key) (*beta.Address, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("beta"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Addresses")

	call := g.s.Beta.Addresses.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Address objects.
func (g *GCEBetaAddresses) List(ctx context.Context, region string) ([]*beta.Address, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("beta"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Addresses")

	call := g.s.Beta.Addresses.List(projectID, region)

	var all []*beta.Address
	f := func(l *beta.AddressList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEBetaAddresses) Insert(ctx context.Context, key meta.Key, obj *beta.Address) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Addresses")
	obj.Name = key.Name

	call := g.s.Beta.Addresses.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Address referenced by key.
func (g *GCEBetaAddresses) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Addresses")

	call := g.s.Beta.Addresses.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// GlobalAddresses is an interface that allows for mocking of GlobalAddresses.
type GlobalAddresses interface {
	Get(ctx context.Context, key meta.Key) (*ga.Address, error)
	List(ctx context.Context) ([]*ga.Address, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.Address) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockGlobalAddresses returns a new mock for GlobalAddresses.
func NewMockGlobalAddresses() *MockGlobalAddresses {
	mock := &MockGlobalAddresses{
		Objects:     map[meta.Key]*ga.Address{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockGlobalAddresses is the mock for GlobalAddresses.
type MockGlobalAddresses struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Address

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockGlobalAddresses, ctx context.Context, key meta.Key) (bool, *ga.Address, error)
	ListHook   func(m *MockGlobalAddresses, ctx context.Context) (bool, []*ga.Address, error)
	InsertHook func(m *MockGlobalAddresses, ctx context.Context, key meta.Key, obj *ga.Address) (bool, error)
	DeleteHook func(m *MockGlobalAddresses, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockGlobalAddresses) Get(ctx context.Context, key meta.Key) (*ga.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockGlobalAddresses %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockGlobalAddresses) List(ctx context.Context) ([]*ga.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Address
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockGlobalAddresses) Insert(ctx context.Context, key meta.Key, obj *ga.Address) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockGlobalAddresses %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockGlobalAddresses) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockGlobalAddresses %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEGlobalAddresses is a simplifying adapter for the GCE GlobalAddresses.
type GCEGlobalAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEGlobalAddresses) Get(ctx context.Context, key meta.Key) (*ga.Address, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalAddresses")

	call := g.s.GA.GlobalAddresses.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Address objects.
func (g *GCEGlobalAddresses) List(ctx context.Context) ([]*ga.Address, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalAddresses")

	call := g.s.GA.GlobalAddresses.List(projectID)

	var all []*ga.Address
	f := func(l *ga.AddressList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEGlobalAddresses) Insert(ctx context.Context, key meta.Key, obj *ga.Address) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalAddresses")
	obj.Name = key.Name

	call := g.s.GA.GlobalAddresses.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Address referenced by key.
func (g *GCEGlobalAddresses) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "Address",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalAddresses")

	call := g.s.GA.GlobalAddresses.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// BackendServices is an interface that allows for mocking of BackendServices.
type BackendServices interface {
	Get(ctx context.Context, key meta.Key) (*ga.BackendService, error)
	List(ctx context.Context) ([]*ga.BackendService, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.BackendService) error
	Delete(ctx context.Context, key meta.Key) error

	GetHealth(context.Context, meta.Key, *ga.ResourceGroupReference) (*ga.BackendServiceGroupHealth, error)
	Update(context.Context, meta.Key, *ga.BackendService) error
}

// NewMockBackendServices returns a new mock for BackendServices.
func NewMockBackendServices() *MockBackendServices {
	mock := &MockBackendServices{
		Objects:     map[meta.Key]*ga.BackendService{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBackendServices is the mock for BackendServices.
type MockBackendServices struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.BackendService

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockBackendServices, ctx context.Context, key meta.Key) (bool, *ga.BackendService, error)
	ListHook   func(m *MockBackendServices, ctx context.Context) (bool, []*ga.BackendService, error)
	InsertHook func(m *MockBackendServices, ctx context.Context, key meta.Key, obj *ga.BackendService) (bool, error)
	DeleteHook func(m *MockBackendServices, ctx context.Context, key meta.Key) (bool, error)

	GetHealthHook func(*MockBackendServices, context.Context, meta.Key, *ga.ResourceGroupReference) (*ga.BackendServiceGroupHealth, error)
	UpdateHook    func(*MockBackendServices, context.Context, meta.Key, *ga.BackendService) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBackendServices) Get(ctx context.Context, key meta.Key) (*ga.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBackendServices %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockBackendServices) List(ctx context.Context) ([]*ga.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.BackendService
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBackendServices) Insert(ctx context.Context, key meta.Key, obj *ga.BackendService) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBackendServices %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBackendServices) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBackendServices %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockBackendServices) GetHealth(ctx context.Context, key meta.Key, arg0 *ga.ResourceGroupReference) (*ga.BackendServiceGroupHealth, error) {

	if m.GetHealthHook != nil {
		return m.GetHealthHook(m, ctx, key, arg0)
	}
	return nil, fmt.Errorf("GetHealthHook must be set")
}

func (m *MockBackendServices) Update(ctx context.Context, key meta.Key, arg0 *ga.BackendService) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEBackendServices is a simplifying adapter for the GCE BackendServices.
type GCEBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEBackendServices) Get(ctx context.Context, key meta.Key) (*ga.BackendService, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "BackendServices")

	call := g.s.GA.BackendServices.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all BackendService objects.
func (g *GCEBackendServices) List(ctx context.Context) ([]*ga.BackendService, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "BackendServices")

	call := g.s.GA.BackendServices.List(projectID)

	var all []*ga.BackendService
	f := func(l *ga.BackendServiceList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEBackendServices) Insert(ctx context.Context, key meta.Key, obj *ga.BackendService) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "BackendServices")
	obj.Name = key.Name

	call := g.s.GA.BackendServices.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the BackendService referenced by key.
func (g *GCEBackendServices) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "BackendServices")

	call := g.s.GA.BackendServices.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEBackendServices) GetHealth(ctx context.Context, key meta.Key, arg0 *ga.ResourceGroupReference) (*ga.BackendServiceGroupHealth, error) {
	rk := &RateLimitKey{
		Operation: "GetHealth",
		Version:   meta.Version("ga"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "BackendServices")

	call := g.s.GA.BackendServices.GetHealth(projectID, key.Name, arg0)

	call.Context(ctx)
	return call.Do()
}

func (g *GCEBackendServices) Update(ctx context.Context, key meta.Key, arg0 *ga.BackendService) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("ga"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "BackendServices")

	call := g.s.GA.BackendServices.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// AlphaBackendServices is an interface that allows for mocking of BackendServices.
type AlphaBackendServices interface {
	Get(ctx context.Context, key meta.Key) (*alpha.BackendService, error)
	List(ctx context.Context) ([]*alpha.BackendService, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.BackendService) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *alpha.BackendService) error
}

// NewMockAlphaBackendServices returns a new mock for BackendServices.
func NewMockAlphaBackendServices() *MockAlphaBackendServices {
	mock := &MockAlphaBackendServices{
		Objects:     map[meta.Key]*alpha.BackendService{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaBackendServices is the mock for BackendServices.
type MockAlphaBackendServices struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.BackendService

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaBackendServices, ctx context.Context, key meta.Key) (bool, *alpha.BackendService, error)
	ListHook   func(m *MockAlphaBackendServices, ctx context.Context) (bool, []*alpha.BackendService, error)
	InsertHook func(m *MockAlphaBackendServices, ctx context.Context, key meta.Key, obj *alpha.BackendService) (bool, error)
	DeleteHook func(m *MockAlphaBackendServices, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockAlphaBackendServices, context.Context, meta.Key, *alpha.BackendService) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaBackendServices) Get(ctx context.Context, key meta.Key) (*alpha.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaBackendServices %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockAlphaBackendServices) List(ctx context.Context) ([]*alpha.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.BackendService
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaBackendServices) Insert(ctx context.Context, key meta.Key, obj *alpha.BackendService) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaBackendServices %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaBackendServices) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaBackendServices %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockAlphaBackendServices) Update(ctx context.Context, key meta.Key, arg0 *alpha.BackendService) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEAlphaBackendServices is a simplifying adapter for the GCE BackendServices.
type GCEAlphaBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEAlphaBackendServices) Get(ctx context.Context, key meta.Key) (*alpha.BackendService, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "BackendServices")

	call := g.s.Alpha.BackendServices.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all BackendService objects.
func (g *GCEAlphaBackendServices) List(ctx context.Context) ([]*alpha.BackendService, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "BackendServices")

	call := g.s.Alpha.BackendServices.List(projectID)

	var all []*alpha.BackendService
	f := func(l *alpha.BackendServiceList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEAlphaBackendServices) Insert(ctx context.Context, key meta.Key, obj *alpha.BackendService) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "BackendServices")
	obj.Name = key.Name

	call := g.s.Alpha.BackendServices.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the BackendService referenced by key.
func (g *GCEAlphaBackendServices) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "BackendServices")

	call := g.s.Alpha.BackendServices.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEAlphaBackendServices) Update(ctx context.Context, key meta.Key, arg0 *alpha.BackendService) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "BackendServices")

	call := g.s.Alpha.BackendServices.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// AlphaRegionBackendServices is an interface that allows for mocking of RegionBackendServices.
type AlphaRegionBackendServices interface {
	Get(ctx context.Context, key meta.Key) (*alpha.BackendService, error)
	List(ctx context.Context, region string) ([]*alpha.BackendService, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.BackendService) error
	Delete(ctx context.Context, key meta.Key) error

	GetHealth(context.Context, meta.Key, *alpha.ResourceGroupReference) (*alpha.BackendServiceGroupHealth, error)
	Update(context.Context, meta.Key, *alpha.BackendService) error
}

// NewMockAlphaRegionBackendServices returns a new mock for RegionBackendServices.
func NewMockAlphaRegionBackendServices() *MockAlphaRegionBackendServices {
	mock := &MockAlphaRegionBackendServices{
		Objects:     map[meta.Key]*alpha.BackendService{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionBackendServices is the mock for RegionBackendServices.
type MockAlphaRegionBackendServices struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.BackendService

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaRegionBackendServices, ctx context.Context, key meta.Key) (bool, *alpha.BackendService, error)
	ListHook   func(m *MockAlphaRegionBackendServices, ctx context.Context) (bool, []*alpha.BackendService, error)
	InsertHook func(m *MockAlphaRegionBackendServices, ctx context.Context, key meta.Key, obj *alpha.BackendService) (bool, error)
	DeleteHook func(m *MockAlphaRegionBackendServices, ctx context.Context, key meta.Key) (bool, error)

	GetHealthHook func(*MockAlphaRegionBackendServices, context.Context, meta.Key, *alpha.ResourceGroupReference) (*alpha.BackendServiceGroupHealth, error)
	UpdateHook    func(*MockAlphaRegionBackendServices, context.Context, meta.Key, *alpha.BackendService) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionBackendServices) Get(ctx context.Context, key meta.Key) (*alpha.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionBackendServices %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionBackendServices) List(ctx context.Context, region string) ([]*alpha.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.BackendService
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionBackendServices) Insert(ctx context.Context, key meta.Key, obj *alpha.BackendService) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionBackendServices %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionBackendServices) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionBackendServices %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockAlphaRegionBackendServices) GetHealth(ctx context.Context, key meta.Key, arg0 *alpha.ResourceGroupReference) (*alpha.BackendServiceGroupHealth, error) {

	if m.GetHealthHook != nil {
		return m.GetHealthHook(m, ctx, key, arg0)
	}
	return nil, fmt.Errorf("GetHealthHook must be set")
}

func (m *MockAlphaRegionBackendServices) Update(ctx context.Context, key meta.Key, arg0 *alpha.BackendService) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEAlphaRegionBackendServices is a simplifying adapter for the GCE RegionBackendServices.
type GCEAlphaRegionBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEAlphaRegionBackendServices) Get(ctx context.Context, key meta.Key) (*alpha.BackendService, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionBackendServices")

	call := g.s.Alpha.RegionBackendServices.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all BackendService objects.
func (g *GCEAlphaRegionBackendServices) List(ctx context.Context, region string) ([]*alpha.BackendService, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionBackendServices")

	call := g.s.Alpha.RegionBackendServices.List(projectID, region)

	var all []*alpha.BackendService
	f := func(l *alpha.BackendServiceList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEAlphaRegionBackendServices) Insert(ctx context.Context, key meta.Key, obj *alpha.BackendService) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionBackendServices")
	obj.Name = key.Name

	call := g.s.Alpha.RegionBackendServices.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the BackendService referenced by key.
func (g *GCEAlphaRegionBackendServices) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionBackendServices")

	call := g.s.Alpha.RegionBackendServices.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEAlphaRegionBackendServices) GetHealth(ctx context.Context, key meta.Key, arg0 *alpha.ResourceGroupReference) (*alpha.BackendServiceGroupHealth, error) {
	rk := &RateLimitKey{
		Operation: "GetHealth",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionBackendServices")

	call := g.s.Alpha.RegionBackendServices.GetHealth(projectID, key.Region, key.Name, arg0)

	call.Context(ctx)
	return call.Do()
}

func (g *GCEAlphaRegionBackendServices) Update(ctx context.Context, key meta.Key, arg0 *alpha.BackendService) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Target:    "BackendService",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionBackendServices")

	call := g.s.Alpha.RegionBackendServices.Update(projectID, key.Region, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// Disks is an interface that allows for mocking of Disks.
type Disks interface {
	Get(ctx context.Context, key meta.Key) (*ga.Disk, error)
	List(ctx context.Context, zone string) ([]*ga.Disk, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.Disk) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockDisks returns a new mock for Disks.
func NewMockDisks() *MockDisks {
	mock := &MockDisks{
		Objects:     map[meta.Key]*ga.Disk{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockDisks is the mock for Disks.
type MockDisks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Disk

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockDisks, ctx context.Context, key meta.Key) (bool, *ga.Disk, error)
	ListHook   func(m *MockDisks, ctx context.Context) (bool, []*ga.Disk, error)
	InsertHook func(m *MockDisks, ctx context.Context, key meta.Key, obj *ga.Disk) (bool, error)
	DeleteHook func(m *MockDisks, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockDisks) Get(ctx context.Context, key meta.Key) (*ga.Disk, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockDisks %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockDisks) List(ctx context.Context, zone string) ([]*ga.Disk, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Disk
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockDisks) Insert(ctx context.Context, key meta.Key, obj *ga.Disk) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockDisks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockDisks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockDisks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEDisks is a simplifying adapter for the GCE Disks.
type GCEDisks struct {
	s *Service
}

// Get the Disk named by key.
func (g *GCEDisks) Get(ctx context.Context, key meta.Key) (*ga.Disk, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Disks")

	call := g.s.GA.Disks.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Disk objects.
func (g *GCEDisks) List(ctx context.Context, zone string) ([]*ga.Disk, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Disks")

	call := g.s.GA.Disks.List(projectID, zone)

	var all []*ga.Disk
	f := func(l *ga.DiskList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Disk with key of value obj.
func (g *GCEDisks) Insert(ctx context.Context, key meta.Key, obj *ga.Disk) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Disks")
	obj.Name = key.Name

	call := g.s.GA.Disks.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Disk referenced by key.
func (g *GCEDisks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Disks")

	call := g.s.GA.Disks.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// AlphaDisks is an interface that allows for mocking of Disks.
type AlphaDisks interface {
	Get(ctx context.Context, key meta.Key) (*alpha.Disk, error)
	List(ctx context.Context, zone string) ([]*alpha.Disk, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.Disk) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockAlphaDisks returns a new mock for Disks.
func NewMockAlphaDisks() *MockAlphaDisks {
	mock := &MockAlphaDisks{
		Objects:     map[meta.Key]*alpha.Disk{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaDisks is the mock for Disks.
type MockAlphaDisks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.Disk

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaDisks, ctx context.Context, key meta.Key) (bool, *alpha.Disk, error)
	ListHook   func(m *MockAlphaDisks, ctx context.Context) (bool, []*alpha.Disk, error)
	InsertHook func(m *MockAlphaDisks, ctx context.Context, key meta.Key, obj *alpha.Disk) (bool, error)
	DeleteHook func(m *MockAlphaDisks, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaDisks) Get(ctx context.Context, key meta.Key) (*alpha.Disk, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaDisks %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockAlphaDisks) List(ctx context.Context, zone string) ([]*alpha.Disk, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.Disk
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaDisks) Insert(ctx context.Context, key meta.Key, obj *alpha.Disk) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaDisks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaDisks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaDisks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEAlphaDisks is a simplifying adapter for the GCE Disks.
type GCEAlphaDisks struct {
	s *Service
}

// Get the Disk named by key.
func (g *GCEAlphaDisks) Get(ctx context.Context, key meta.Key) (*alpha.Disk, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Disks")

	call := g.s.Alpha.Disks.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Disk objects.
func (g *GCEAlphaDisks) List(ctx context.Context, zone string) ([]*alpha.Disk, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Disks")

	call := g.s.Alpha.Disks.List(projectID, zone)

	var all []*alpha.Disk
	f := func(l *alpha.DiskList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Disk with key of value obj.
func (g *GCEAlphaDisks) Insert(ctx context.Context, key meta.Key, obj *alpha.Disk) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Disks")
	obj.Name = key.Name

	call := g.s.Alpha.Disks.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Disk referenced by key.
func (g *GCEAlphaDisks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Disks")

	call := g.s.Alpha.Disks.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// AlphaRegionDisks is an interface that allows for mocking of RegionDisks.
type AlphaRegionDisks interface {
	Get(ctx context.Context, key meta.Key) (*alpha.Disk, error)
	List(ctx context.Context, region string) ([]*alpha.Disk, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.Disk) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockAlphaRegionDisks returns a new mock for RegionDisks.
func NewMockAlphaRegionDisks() *MockAlphaRegionDisks {
	mock := &MockAlphaRegionDisks{
		Objects:     map[meta.Key]*alpha.Disk{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionDisks is the mock for RegionDisks.
type MockAlphaRegionDisks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.Disk

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaRegionDisks, ctx context.Context, key meta.Key) (bool, *alpha.Disk, error)
	ListHook   func(m *MockAlphaRegionDisks, ctx context.Context) (bool, []*alpha.Disk, error)
	InsertHook func(m *MockAlphaRegionDisks, ctx context.Context, key meta.Key, obj *alpha.Disk) (bool, error)
	DeleteHook func(m *MockAlphaRegionDisks, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionDisks) Get(ctx context.Context, key meta.Key) (*alpha.Disk, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionDisks %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionDisks) List(ctx context.Context, region string) ([]*alpha.Disk, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.Disk
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionDisks) Insert(ctx context.Context, key meta.Key, obj *alpha.Disk) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionDisks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionDisks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionDisks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEAlphaRegionDisks is a simplifying adapter for the GCE RegionDisks.
type GCEAlphaRegionDisks struct {
	s *Service
}

// Get the Disk named by key.
func (g *GCEAlphaRegionDisks) Get(ctx context.Context, key meta.Key) (*alpha.Disk, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionDisks")

	call := g.s.Alpha.RegionDisks.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Disk objects.
func (g *GCEAlphaRegionDisks) List(ctx context.Context, region string) ([]*alpha.Disk, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionDisks")

	call := g.s.Alpha.RegionDisks.List(projectID, region)

	var all []*alpha.Disk
	f := func(l *alpha.DiskList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Disk with key of value obj.
func (g *GCEAlphaRegionDisks) Insert(ctx context.Context, key meta.Key, obj *alpha.Disk) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionDisks")
	obj.Name = key.Name

	call := g.s.Alpha.RegionDisks.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Disk referenced by key.
func (g *GCEAlphaRegionDisks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "Disk",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "RegionDisks")

	call := g.s.Alpha.RegionDisks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Firewalls is an interface that allows for mocking of Firewalls.
type Firewalls interface {
	Get(ctx context.Context, key meta.Key) (*ga.Firewall, error)
	List(ctx context.Context) ([]*ga.Firewall, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.Firewall) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *ga.Firewall) error
}

// NewMockFirewalls returns a new mock for Firewalls.
func NewMockFirewalls() *MockFirewalls {
	mock := &MockFirewalls{
		Objects:     map[meta.Key]*ga.Firewall{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockFirewalls is the mock for Firewalls.
type MockFirewalls struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Firewall

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockFirewalls, ctx context.Context, key meta.Key) (bool, *ga.Firewall, error)
	ListHook   func(m *MockFirewalls, ctx context.Context) (bool, []*ga.Firewall, error)
	InsertHook func(m *MockFirewalls, ctx context.Context, key meta.Key, obj *ga.Firewall) (bool, error)
	DeleteHook func(m *MockFirewalls, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockFirewalls, context.Context, meta.Key, *ga.Firewall) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockFirewalls) Get(ctx context.Context, key meta.Key) (*ga.Firewall, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockFirewalls %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockFirewalls) List(ctx context.Context) ([]*ga.Firewall, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Firewall
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockFirewalls) Insert(ctx context.Context, key meta.Key, obj *ga.Firewall) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockFirewalls %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockFirewalls) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockFirewalls %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockFirewalls) Update(ctx context.Context, key meta.Key, arg0 *ga.Firewall) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEFirewalls is a simplifying adapter for the GCE Firewalls.
type GCEFirewalls struct {
	s *Service
}

// Get the Firewall named by key.
func (g *GCEFirewalls) Get(ctx context.Context, key meta.Key) (*ga.Firewall, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Firewall",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Firewalls")

	call := g.s.GA.Firewalls.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Firewall objects.
func (g *GCEFirewalls) List(ctx context.Context) ([]*ga.Firewall, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Firewall",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Firewalls")

	call := g.s.GA.Firewalls.List(projectID)

	var all []*ga.Firewall
	f := func(l *ga.FirewallList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Firewall with key of value obj.
func (g *GCEFirewalls) Insert(ctx context.Context, key meta.Key, obj *ga.Firewall) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "Firewall",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Firewalls")
	obj.Name = key.Name

	call := g.s.GA.Firewalls.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Firewall referenced by key.
func (g *GCEFirewalls) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "Firewall",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Firewalls")

	call := g.s.GA.Firewalls.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEFirewalls) Update(ctx context.Context, key meta.Key, arg0 *ga.Firewall) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("ga"),
		Target:    "Firewall",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Firewalls")

	call := g.s.GA.Firewalls.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// ForwardingRules is an interface that allows for mocking of ForwardingRules.
type ForwardingRules interface {
	Get(ctx context.Context, key meta.Key) (*ga.ForwardingRule, error)
	List(ctx context.Context, region string) ([]*ga.ForwardingRule, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.ForwardingRule) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockForwardingRules returns a new mock for ForwardingRules.
func NewMockForwardingRules() *MockForwardingRules {
	mock := &MockForwardingRules{
		Objects:     map[meta.Key]*ga.ForwardingRule{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockForwardingRules is the mock for ForwardingRules.
type MockForwardingRules struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.ForwardingRule

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockForwardingRules, ctx context.Context, key meta.Key) (bool, *ga.ForwardingRule, error)
	ListHook   func(m *MockForwardingRules, ctx context.Context) (bool, []*ga.ForwardingRule, error)
	InsertHook func(m *MockForwardingRules, ctx context.Context, key meta.Key, obj *ga.ForwardingRule) (bool, error)
	DeleteHook func(m *MockForwardingRules, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockForwardingRules) Get(ctx context.Context, key meta.Key) (*ga.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockForwardingRules %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockForwardingRules) List(ctx context.Context, region string) ([]*ga.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.ForwardingRule
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockForwardingRules) Insert(ctx context.Context, key meta.Key, obj *ga.ForwardingRule) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockForwardingRules %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockForwardingRules) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockForwardingRules %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEForwardingRules is a simplifying adapter for the GCE ForwardingRules.
type GCEForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEForwardingRules) Get(ctx context.Context, key meta.Key) (*ga.ForwardingRule, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "ForwardingRules")

	call := g.s.GA.ForwardingRules.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all ForwardingRule objects.
func (g *GCEForwardingRules) List(ctx context.Context, region string) ([]*ga.ForwardingRule, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "ForwardingRules")

	call := g.s.GA.ForwardingRules.List(projectID, region)

	var all []*ga.ForwardingRule
	f := func(l *ga.ForwardingRuleList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEForwardingRules) Insert(ctx context.Context, key meta.Key, obj *ga.ForwardingRule) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "ForwardingRules")
	obj.Name = key.Name

	call := g.s.GA.ForwardingRules.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the ForwardingRule referenced by key.
func (g *GCEForwardingRules) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "ForwardingRules")

	call := g.s.GA.ForwardingRules.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// AlphaForwardingRules is an interface that allows for mocking of ForwardingRules.
type AlphaForwardingRules interface {
	Get(ctx context.Context, key meta.Key) (*alpha.ForwardingRule, error)
	List(ctx context.Context, region string) ([]*alpha.ForwardingRule, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.ForwardingRule) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockAlphaForwardingRules returns a new mock for ForwardingRules.
func NewMockAlphaForwardingRules() *MockAlphaForwardingRules {
	mock := &MockAlphaForwardingRules{
		Objects:     map[meta.Key]*alpha.ForwardingRule{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaForwardingRules is the mock for ForwardingRules.
type MockAlphaForwardingRules struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.ForwardingRule

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaForwardingRules, ctx context.Context, key meta.Key) (bool, *alpha.ForwardingRule, error)
	ListHook   func(m *MockAlphaForwardingRules, ctx context.Context) (bool, []*alpha.ForwardingRule, error)
	InsertHook func(m *MockAlphaForwardingRules, ctx context.Context, key meta.Key, obj *alpha.ForwardingRule) (bool, error)
	DeleteHook func(m *MockAlphaForwardingRules, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaForwardingRules) Get(ctx context.Context, key meta.Key) (*alpha.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaForwardingRules %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaForwardingRules) List(ctx context.Context, region string) ([]*alpha.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.ForwardingRule
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaForwardingRules) Insert(ctx context.Context, key meta.Key, obj *alpha.ForwardingRule) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaForwardingRules %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaForwardingRules) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaForwardingRules %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCEAlphaForwardingRules is a simplifying adapter for the GCE ForwardingRules.
type GCEAlphaForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEAlphaForwardingRules) Get(ctx context.Context, key meta.Key) (*alpha.ForwardingRule, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "ForwardingRules")

	call := g.s.Alpha.ForwardingRules.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all ForwardingRule objects.
func (g *GCEAlphaForwardingRules) List(ctx context.Context, region string) ([]*alpha.ForwardingRule, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "ForwardingRules")

	call := g.s.Alpha.ForwardingRules.List(projectID, region)

	var all []*alpha.ForwardingRule
	f := func(l *alpha.ForwardingRuleList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEAlphaForwardingRules) Insert(ctx context.Context, key meta.Key, obj *alpha.ForwardingRule) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "ForwardingRules")
	obj.Name = key.Name

	call := g.s.Alpha.ForwardingRules.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the ForwardingRule referenced by key.
func (g *GCEAlphaForwardingRules) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "ForwardingRules")

	call := g.s.Alpha.ForwardingRules.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// GlobalForwardingRules is an interface that allows for mocking of GlobalForwardingRules.
type GlobalForwardingRules interface {
	Get(ctx context.Context, key meta.Key) (*ga.ForwardingRule, error)
	List(ctx context.Context) ([]*ga.ForwardingRule, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.ForwardingRule) error
	Delete(ctx context.Context, key meta.Key) error

	SetTarget(context.Context, meta.Key, *ga.TargetReference) error
}

// NewMockGlobalForwardingRules returns a new mock for GlobalForwardingRules.
func NewMockGlobalForwardingRules() *MockGlobalForwardingRules {
	mock := &MockGlobalForwardingRules{
		Objects:     map[meta.Key]*ga.ForwardingRule{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockGlobalForwardingRules is the mock for GlobalForwardingRules.
type MockGlobalForwardingRules struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.ForwardingRule

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockGlobalForwardingRules, ctx context.Context, key meta.Key) (bool, *ga.ForwardingRule, error)
	ListHook   func(m *MockGlobalForwardingRules, ctx context.Context) (bool, []*ga.ForwardingRule, error)
	InsertHook func(m *MockGlobalForwardingRules, ctx context.Context, key meta.Key, obj *ga.ForwardingRule) (bool, error)
	DeleteHook func(m *MockGlobalForwardingRules, ctx context.Context, key meta.Key) (bool, error)

	SetTargetHook func(*MockGlobalForwardingRules, context.Context, meta.Key, *ga.TargetReference) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockGlobalForwardingRules) Get(ctx context.Context, key meta.Key) (*ga.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockGlobalForwardingRules %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockGlobalForwardingRules) List(ctx context.Context) ([]*ga.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.ForwardingRule
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockGlobalForwardingRules) Insert(ctx context.Context, key meta.Key, obj *ga.ForwardingRule) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockGlobalForwardingRules %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockGlobalForwardingRules) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockGlobalForwardingRules %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockGlobalForwardingRules) SetTarget(ctx context.Context, key meta.Key, arg0 *ga.TargetReference) error {

	if m.SetTargetHook != nil {
		return m.SetTargetHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEGlobalForwardingRules is a simplifying adapter for the GCE GlobalForwardingRules.
type GCEGlobalForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEGlobalForwardingRules) Get(ctx context.Context, key meta.Key) (*ga.ForwardingRule, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalForwardingRules")

	call := g.s.GA.GlobalForwardingRules.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all ForwardingRule objects.
func (g *GCEGlobalForwardingRules) List(ctx context.Context) ([]*ga.ForwardingRule, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalForwardingRules")

	call := g.s.GA.GlobalForwardingRules.List(projectID)

	var all []*ga.ForwardingRule
	f := func(l *ga.ForwardingRuleList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEGlobalForwardingRules) Insert(ctx context.Context, key meta.Key, obj *ga.ForwardingRule) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalForwardingRules")
	obj.Name = key.Name

	call := g.s.GA.GlobalForwardingRules.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the ForwardingRule referenced by key.
func (g *GCEGlobalForwardingRules) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalForwardingRules")

	call := g.s.GA.GlobalForwardingRules.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEGlobalForwardingRules) SetTarget(ctx context.Context, key meta.Key, arg0 *ga.TargetReference) error {
	rk := &RateLimitKey{
		Operation: "SetTarget",
		Version:   meta.Version("ga"),
		Target:    "ForwardingRule",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "GlobalForwardingRules")

	call := g.s.GA.GlobalForwardingRules.SetTarget(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// HealthChecks is an interface that allows for mocking of HealthChecks.
type HealthChecks interface {
	Get(ctx context.Context, key meta.Key) (*ga.HealthCheck, error)
	List(ctx context.Context) ([]*ga.HealthCheck, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.HealthCheck) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *ga.HealthCheck) error
}

// NewMockHealthChecks returns a new mock for HealthChecks.
func NewMockHealthChecks() *MockHealthChecks {
	mock := &MockHealthChecks{
		Objects:     map[meta.Key]*ga.HealthCheck{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockHealthChecks is the mock for HealthChecks.
type MockHealthChecks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.HealthCheck

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockHealthChecks, ctx context.Context, key meta.Key) (bool, *ga.HealthCheck, error)
	ListHook   func(m *MockHealthChecks, ctx context.Context) (bool, []*ga.HealthCheck, error)
	InsertHook func(m *MockHealthChecks, ctx context.Context, key meta.Key, obj *ga.HealthCheck) (bool, error)
	DeleteHook func(m *MockHealthChecks, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockHealthChecks, context.Context, meta.Key, *ga.HealthCheck) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockHealthChecks) Get(ctx context.Context, key meta.Key) (*ga.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockHealthChecks %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockHealthChecks) List(ctx context.Context) ([]*ga.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.HealthCheck
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockHealthChecks) Insert(ctx context.Context, key meta.Key, obj *ga.HealthCheck) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockHealthChecks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockHealthChecks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *ga.HealthCheck) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEHealthChecks is a simplifying adapter for the GCE HealthChecks.
type GCEHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEHealthChecks) Get(ctx context.Context, key meta.Key) (*ga.HealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HealthChecks")

	call := g.s.GA.HealthChecks.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all HealthCheck objects.
func (g *GCEHealthChecks) List(ctx context.Context) ([]*ga.HealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HealthChecks")

	call := g.s.GA.HealthChecks.List(projectID)

	var all []*ga.HealthCheck
	f := func(l *ga.HealthCheckList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEHealthChecks) Insert(ctx context.Context, key meta.Key, obj *ga.HealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HealthChecks")
	obj.Name = key.Name

	call := g.s.GA.HealthChecks.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the HealthCheck referenced by key.
func (g *GCEHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HealthChecks")

	call := g.s.GA.HealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *ga.HealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("ga"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HealthChecks")

	call := g.s.GA.HealthChecks.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// AlphaHealthChecks is an interface that allows for mocking of HealthChecks.
type AlphaHealthChecks interface {
	Get(ctx context.Context, key meta.Key) (*alpha.HealthCheck, error)
	List(ctx context.Context) ([]*alpha.HealthCheck, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.HealthCheck) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *alpha.HealthCheck) error
}

// NewMockAlphaHealthChecks returns a new mock for HealthChecks.
func NewMockAlphaHealthChecks() *MockAlphaHealthChecks {
	mock := &MockAlphaHealthChecks{
		Objects:     map[meta.Key]*alpha.HealthCheck{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaHealthChecks is the mock for HealthChecks.
type MockAlphaHealthChecks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.HealthCheck

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaHealthChecks, ctx context.Context, key meta.Key) (bool, *alpha.HealthCheck, error)
	ListHook   func(m *MockAlphaHealthChecks, ctx context.Context) (bool, []*alpha.HealthCheck, error)
	InsertHook func(m *MockAlphaHealthChecks, ctx context.Context, key meta.Key, obj *alpha.HealthCheck) (bool, error)
	DeleteHook func(m *MockAlphaHealthChecks, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockAlphaHealthChecks, context.Context, meta.Key, *alpha.HealthCheck) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaHealthChecks) Get(ctx context.Context, key meta.Key) (*alpha.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaHealthChecks %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockAlphaHealthChecks) List(ctx context.Context) ([]*alpha.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.HealthCheck
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaHealthChecks) Insert(ctx context.Context, key meta.Key, obj *alpha.HealthCheck) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaHealthChecks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaHealthChecks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockAlphaHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *alpha.HealthCheck) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEAlphaHealthChecks is a simplifying adapter for the GCE HealthChecks.
type GCEAlphaHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEAlphaHealthChecks) Get(ctx context.Context, key meta.Key) (*alpha.HealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "HealthChecks")

	call := g.s.Alpha.HealthChecks.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all HealthCheck objects.
func (g *GCEAlphaHealthChecks) List(ctx context.Context) ([]*alpha.HealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "HealthChecks")

	call := g.s.Alpha.HealthChecks.List(projectID)

	var all []*alpha.HealthCheck
	f := func(l *alpha.HealthCheckList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEAlphaHealthChecks) Insert(ctx context.Context, key meta.Key, obj *alpha.HealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "HealthChecks")
	obj.Name = key.Name

	call := g.s.Alpha.HealthChecks.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the HealthCheck referenced by key.
func (g *GCEAlphaHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "HealthChecks")

	call := g.s.Alpha.HealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEAlphaHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *alpha.HealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Target:    "HealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "HealthChecks")

	call := g.s.Alpha.HealthChecks.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// HttpHealthChecks is an interface that allows for mocking of HttpHealthChecks.
type HttpHealthChecks interface {
	Get(ctx context.Context, key meta.Key) (*ga.HttpHealthCheck, error)
	List(ctx context.Context) ([]*ga.HttpHealthCheck, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.HttpHealthCheck) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *ga.HttpHealthCheck) error
}

// NewMockHttpHealthChecks returns a new mock for HttpHealthChecks.
func NewMockHttpHealthChecks() *MockHttpHealthChecks {
	mock := &MockHttpHealthChecks{
		Objects:     map[meta.Key]*ga.HttpHealthCheck{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockHttpHealthChecks is the mock for HttpHealthChecks.
type MockHttpHealthChecks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.HttpHealthCheck

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockHttpHealthChecks, ctx context.Context, key meta.Key) (bool, *ga.HttpHealthCheck, error)
	ListHook   func(m *MockHttpHealthChecks, ctx context.Context) (bool, []*ga.HttpHealthCheck, error)
	InsertHook func(m *MockHttpHealthChecks, ctx context.Context, key meta.Key, obj *ga.HttpHealthCheck) (bool, error)
	DeleteHook func(m *MockHttpHealthChecks, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockHttpHealthChecks, context.Context, meta.Key, *ga.HttpHealthCheck) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockHttpHealthChecks) Get(ctx context.Context, key meta.Key) (*ga.HttpHealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockHttpHealthChecks %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockHttpHealthChecks) List(ctx context.Context) ([]*ga.HttpHealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.HttpHealthCheck
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockHttpHealthChecks) Insert(ctx context.Context, key meta.Key, obj *ga.HttpHealthCheck) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockHttpHealthChecks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockHttpHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockHttpHealthChecks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockHttpHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *ga.HttpHealthCheck) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEHttpHealthChecks is a simplifying adapter for the GCE HttpHealthChecks.
type GCEHttpHealthChecks struct {
	s *Service
}

// Get the HttpHealthCheck named by key.
func (g *GCEHttpHealthChecks) Get(ctx context.Context, key meta.Key) (*ga.HttpHealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "HttpHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpHealthChecks")

	call := g.s.GA.HttpHealthChecks.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all HttpHealthCheck objects.
func (g *GCEHttpHealthChecks) List(ctx context.Context) ([]*ga.HttpHealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "HttpHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpHealthChecks")

	call := g.s.GA.HttpHealthChecks.List(projectID)

	var all []*ga.HttpHealthCheck
	f := func(l *ga.HttpHealthCheckList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert HttpHealthCheck with key of value obj.
func (g *GCEHttpHealthChecks) Insert(ctx context.Context, key meta.Key, obj *ga.HttpHealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "HttpHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpHealthChecks")
	obj.Name = key.Name

	call := g.s.GA.HttpHealthChecks.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the HttpHealthCheck referenced by key.
func (g *GCEHttpHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "HttpHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpHealthChecks")

	call := g.s.GA.HttpHealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEHttpHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *ga.HttpHealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("ga"),
		Target:    "HttpHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpHealthChecks")

	call := g.s.GA.HttpHealthChecks.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// HttpsHealthChecks is an interface that allows for mocking of HttpsHealthChecks.
type HttpsHealthChecks interface {
	Get(ctx context.Context, key meta.Key) (*ga.HttpsHealthCheck, error)
	List(ctx context.Context) ([]*ga.HttpsHealthCheck, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.HttpsHealthCheck) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *ga.HttpsHealthCheck) error
}

// NewMockHttpsHealthChecks returns a new mock for HttpsHealthChecks.
func NewMockHttpsHealthChecks() *MockHttpsHealthChecks {
	mock := &MockHttpsHealthChecks{
		Objects:     map[meta.Key]*ga.HttpsHealthCheck{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockHttpsHealthChecks is the mock for HttpsHealthChecks.
type MockHttpsHealthChecks struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.HttpsHealthCheck

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockHttpsHealthChecks, ctx context.Context, key meta.Key) (bool, *ga.HttpsHealthCheck, error)
	ListHook   func(m *MockHttpsHealthChecks, ctx context.Context) (bool, []*ga.HttpsHealthCheck, error)
	InsertHook func(m *MockHttpsHealthChecks, ctx context.Context, key meta.Key, obj *ga.HttpsHealthCheck) (bool, error)
	DeleteHook func(m *MockHttpsHealthChecks, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockHttpsHealthChecks, context.Context, meta.Key, *ga.HttpsHealthCheck) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockHttpsHealthChecks) Get(ctx context.Context, key meta.Key) (*ga.HttpsHealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockHttpsHealthChecks %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockHttpsHealthChecks) List(ctx context.Context) ([]*ga.HttpsHealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.HttpsHealthCheck
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockHttpsHealthChecks) Insert(ctx context.Context, key meta.Key, obj *ga.HttpsHealthCheck) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockHttpsHealthChecks %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockHttpsHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockHttpsHealthChecks %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockHttpsHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *ga.HttpsHealthCheck) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEHttpsHealthChecks is a simplifying adapter for the GCE HttpsHealthChecks.
type GCEHttpsHealthChecks struct {
	s *Service
}

// Get the HttpsHealthCheck named by key.
func (g *GCEHttpsHealthChecks) Get(ctx context.Context, key meta.Key) (*ga.HttpsHealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "HttpsHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpsHealthChecks")

	call := g.s.GA.HttpsHealthChecks.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all HttpsHealthCheck objects.
func (g *GCEHttpsHealthChecks) List(ctx context.Context) ([]*ga.HttpsHealthCheck, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "HttpsHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpsHealthChecks")

	call := g.s.GA.HttpsHealthChecks.List(projectID)

	var all []*ga.HttpsHealthCheck
	f := func(l *ga.HttpsHealthCheckList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert HttpsHealthCheck with key of value obj.
func (g *GCEHttpsHealthChecks) Insert(ctx context.Context, key meta.Key, obj *ga.HttpsHealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "HttpsHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpsHealthChecks")
	obj.Name = key.Name

	call := g.s.GA.HttpsHealthChecks.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the HttpsHealthCheck referenced by key.
func (g *GCEHttpsHealthChecks) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "HttpsHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpsHealthChecks")

	call := g.s.GA.HttpsHealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEHttpsHealthChecks) Update(ctx context.Context, key meta.Key, arg0 *ga.HttpsHealthCheck) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("ga"),
		Target:    "HttpsHealthCheck",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "HttpsHealthChecks")

	call := g.s.GA.HttpsHealthChecks.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// InstanceGroups is an interface that allows for mocking of InstanceGroups.
type InstanceGroups interface {
	Get(ctx context.Context, key meta.Key) (*ga.InstanceGroup, error)
	List(ctx context.Context, zone string) ([]*ga.InstanceGroup, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.InstanceGroup) error
	Delete(ctx context.Context, key meta.Key) error

	ListInstances(context.Context, meta.Key, *ga.InstanceGroupsListInstancesRequest) (*ga.InstanceGroupsListInstances, error)
	RemoveInstances(context.Context, meta.Key, *ga.InstanceGroupsRemoveInstancesRequest) error
	SetNamedPorts(context.Context, meta.Key, *ga.InstanceGroupsSetNamedPortsRequest) error
}

// NewMockInstanceGroups returns a new mock for InstanceGroups.
func NewMockInstanceGroups() *MockInstanceGroups {
	mock := &MockInstanceGroups{
		Objects:     map[meta.Key]*ga.InstanceGroup{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockInstanceGroups is the mock for InstanceGroups.
type MockInstanceGroups struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.InstanceGroup

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockInstanceGroups, ctx context.Context, key meta.Key) (bool, *ga.InstanceGroup, error)
	ListHook   func(m *MockInstanceGroups, ctx context.Context) (bool, []*ga.InstanceGroup, error)
	InsertHook func(m *MockInstanceGroups, ctx context.Context, key meta.Key, obj *ga.InstanceGroup) (bool, error)
	DeleteHook func(m *MockInstanceGroups, ctx context.Context, key meta.Key) (bool, error)

	ListInstancesHook   func(*MockInstanceGroups, context.Context, meta.Key, *ga.InstanceGroupsListInstancesRequest) (*ga.InstanceGroupsListInstances, error)
	RemoveInstancesHook func(*MockInstanceGroups, context.Context, meta.Key, *ga.InstanceGroupsRemoveInstancesRequest) error
	SetNamedPortsHook   func(*MockInstanceGroups, context.Context, meta.Key, *ga.InstanceGroupsSetNamedPortsRequest) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockInstanceGroups) Get(ctx context.Context, key meta.Key) (*ga.InstanceGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockInstanceGroups %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockInstanceGroups) List(ctx context.Context, zone string) ([]*ga.InstanceGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.InstanceGroup
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockInstanceGroups) Insert(ctx context.Context, key meta.Key, obj *ga.InstanceGroup) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockInstanceGroups %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockInstanceGroups) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockInstanceGroups %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockInstanceGroups) ListInstances(ctx context.Context, key meta.Key, arg0 *ga.InstanceGroupsListInstancesRequest) (*ga.InstanceGroupsListInstances, error) {

	if m.ListInstancesHook != nil {
		return m.ListInstancesHook(m, ctx, key, arg0)
	}
	return nil, fmt.Errorf("ListInstancesHook must be set")
}

func (m *MockInstanceGroups) RemoveInstances(ctx context.Context, key meta.Key, arg0 *ga.InstanceGroupsRemoveInstancesRequest) error {

	if m.RemoveInstancesHook != nil {
		return m.RemoveInstancesHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockInstanceGroups) SetNamedPorts(ctx context.Context, key meta.Key, arg0 *ga.InstanceGroupsSetNamedPortsRequest) error {

	if m.SetNamedPortsHook != nil {
		return m.SetNamedPortsHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEInstanceGroups is a simplifying adapter for the GCE InstanceGroups.
type GCEInstanceGroups struct {
	s *Service
}

// Get the InstanceGroup named by key.
func (g *GCEInstanceGroups) Get(ctx context.Context, key meta.Key) (*ga.InstanceGroup, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")

	call := g.s.GA.InstanceGroups.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all InstanceGroup objects.
func (g *GCEInstanceGroups) List(ctx context.Context, zone string) ([]*ga.InstanceGroup, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")

	call := g.s.GA.InstanceGroups.List(projectID, zone)

	var all []*ga.InstanceGroup
	f := func(l *ga.InstanceGroupList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert InstanceGroup with key of value obj.
func (g *GCEInstanceGroups) Insert(ctx context.Context, key meta.Key, obj *ga.InstanceGroup) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")
	obj.Name = key.Name

	call := g.s.GA.InstanceGroups.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the InstanceGroup referenced by key.
func (g *GCEInstanceGroups) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")

	call := g.s.GA.InstanceGroups.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEInstanceGroups) ListInstances(ctx context.Context, key meta.Key, arg0 *ga.InstanceGroupsListInstancesRequest) (*ga.InstanceGroupsListInstances, error) {
	rk := &RateLimitKey{
		Operation: "ListInstances",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")

	call := g.s.GA.InstanceGroups.ListInstances(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)
	return call.Do()
}

func (g *GCEInstanceGroups) RemoveInstances(ctx context.Context, key meta.Key, arg0 *ga.InstanceGroupsRemoveInstancesRequest) error {
	rk := &RateLimitKey{
		Operation: "RemoveInstances",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")

	call := g.s.GA.InstanceGroups.RemoveInstances(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCEInstanceGroups) SetNamedPorts(ctx context.Context, key meta.Key, arg0 *ga.InstanceGroupsSetNamedPortsRequest) error {
	rk := &RateLimitKey{
		Operation: "SetNamedPorts",
		Version:   meta.Version("ga"),
		Target:    "InstanceGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "InstanceGroups")

	call := g.s.GA.InstanceGroups.SetNamedPorts(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// Instances is an interface that allows for mocking of Instances.
type Instances interface {
	Get(ctx context.Context, key meta.Key) (*ga.Instance, error)
	List(ctx context.Context, zone string) ([]*ga.Instance, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.Instance) error
	Delete(ctx context.Context, key meta.Key) error

	AttachDisk(context.Context, meta.Key, *ga.AttachedDisk) error
	DetachDisk(context.Context, meta.Key, string) error
}

// NewMockInstances returns a new mock for Instances.
func NewMockInstances() *MockInstances {
	mock := &MockInstances{
		Objects:     map[meta.Key]*ga.Instance{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockInstances is the mock for Instances.
type MockInstances struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Instance

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockInstances, ctx context.Context, key meta.Key) (bool, *ga.Instance, error)
	ListHook   func(m *MockInstances, ctx context.Context) (bool, []*ga.Instance, error)
	InsertHook func(m *MockInstances, ctx context.Context, key meta.Key, obj *ga.Instance) (bool, error)
	DeleteHook func(m *MockInstances, ctx context.Context, key meta.Key) (bool, error)

	AttachDiskHook func(*MockInstances, context.Context, meta.Key, *ga.AttachedDisk) error
	DetachDiskHook func(*MockInstances, context.Context, meta.Key, string) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockInstances) Get(ctx context.Context, key meta.Key) (*ga.Instance, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockInstances %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockInstances) List(ctx context.Context, zone string) ([]*ga.Instance, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Instance
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockInstances) Insert(ctx context.Context, key meta.Key, obj *ga.Instance) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockInstances %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockInstances) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockInstances %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockInstances) AttachDisk(ctx context.Context, key meta.Key, arg0 *ga.AttachedDisk) error {

	if m.AttachDiskHook != nil {
		return m.AttachDiskHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockInstances) DetachDisk(ctx context.Context, key meta.Key, arg0 string) error {

	if m.DetachDiskHook != nil {
		return m.DetachDiskHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEInstances is a simplifying adapter for the GCE Instances.
type GCEInstances struct {
	s *Service
}

// Get the Instance named by key.
func (g *GCEInstances) Get(ctx context.Context, key meta.Key) (*ga.Instance, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Instances")

	call := g.s.GA.Instances.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Instance objects.
func (g *GCEInstances) List(ctx context.Context, zone string) ([]*ga.Instance, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Instances")

	call := g.s.GA.Instances.List(projectID, zone)

	var all []*ga.Instance
	f := func(l *ga.InstanceList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Instance with key of value obj.
func (g *GCEInstances) Insert(ctx context.Context, key meta.Key, obj *ga.Instance) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Instances")
	obj.Name = key.Name

	call := g.s.GA.Instances.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Instance referenced by key.
func (g *GCEInstances) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Instances")

	call := g.s.GA.Instances.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEInstances) AttachDisk(ctx context.Context, key meta.Key, arg0 *ga.AttachedDisk) error {
	rk := &RateLimitKey{
		Operation: "AttachDisk",
		Version:   meta.Version("ga"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Instances")

	call := g.s.GA.Instances.AttachDisk(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCEInstances) DetachDisk(ctx context.Context, key meta.Key, arg0 string) error {
	rk := &RateLimitKey{
		Operation: "DetachDisk",
		Version:   meta.Version("ga"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Instances")

	call := g.s.GA.Instances.DetachDisk(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// BetaInstances is an interface that allows for mocking of Instances.
type BetaInstances interface {
	Get(ctx context.Context, key meta.Key) (*beta.Instance, error)
	List(ctx context.Context, zone string) ([]*beta.Instance, error)
	Insert(ctx context.Context, key meta.Key, obj *beta.Instance) error
	Delete(ctx context.Context, key meta.Key) error

	AttachDisk(context.Context, meta.Key, *beta.AttachedDisk) error
	DetachDisk(context.Context, meta.Key, string) error
}

// NewMockBetaInstances returns a new mock for Instances.
func NewMockBetaInstances() *MockBetaInstances {
	mock := &MockBetaInstances{
		Objects:     map[meta.Key]*beta.Instance{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaInstances is the mock for Instances.
type MockBetaInstances struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*beta.Instance

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockBetaInstances, ctx context.Context, key meta.Key) (bool, *beta.Instance, error)
	ListHook   func(m *MockBetaInstances, ctx context.Context) (bool, []*beta.Instance, error)
	InsertHook func(m *MockBetaInstances, ctx context.Context, key meta.Key, obj *beta.Instance) (bool, error)
	DeleteHook func(m *MockBetaInstances, ctx context.Context, key meta.Key) (bool, error)

	AttachDiskHook func(*MockBetaInstances, context.Context, meta.Key, *beta.AttachedDisk) error
	DetachDiskHook func(*MockBetaInstances, context.Context, meta.Key, string) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaInstances) Get(ctx context.Context, key meta.Key) (*beta.Instance, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaInstances %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockBetaInstances) List(ctx context.Context, zone string) ([]*beta.Instance, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*beta.Instance
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaInstances) Insert(ctx context.Context, key meta.Key, obj *beta.Instance) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaInstances %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaInstances) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaInstances %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockBetaInstances) AttachDisk(ctx context.Context, key meta.Key, arg0 *beta.AttachedDisk) error {

	if m.AttachDiskHook != nil {
		return m.AttachDiskHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockBetaInstances) DetachDisk(ctx context.Context, key meta.Key, arg0 string) error {

	if m.DetachDiskHook != nil {
		return m.DetachDiskHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEBetaInstances is a simplifying adapter for the GCE Instances.
type GCEBetaInstances struct {
	s *Service
}

// Get the Instance named by key.
func (g *GCEBetaInstances) Get(ctx context.Context, key meta.Key) (*beta.Instance, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("beta"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Instances")

	call := g.s.Beta.Instances.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Instance objects.
func (g *GCEBetaInstances) List(ctx context.Context, zone string) ([]*beta.Instance, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("beta"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Instances")

	call := g.s.Beta.Instances.List(projectID, zone)

	var all []*beta.Instance
	f := func(l *beta.InstanceList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Instance with key of value obj.
func (g *GCEBetaInstances) Insert(ctx context.Context, key meta.Key, obj *beta.Instance) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Instances")
	obj.Name = key.Name

	call := g.s.Beta.Instances.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Instance referenced by key.
func (g *GCEBetaInstances) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Instances")

	call := g.s.Beta.Instances.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEBetaInstances) AttachDisk(ctx context.Context, key meta.Key, arg0 *beta.AttachedDisk) error {
	rk := &RateLimitKey{
		Operation: "AttachDisk",
		Version:   meta.Version("beta"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Instances")

	call := g.s.Beta.Instances.AttachDisk(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCEBetaInstances) DetachDisk(ctx context.Context, key meta.Key, arg0 string) error {
	rk := &RateLimitKey{
		Operation: "DetachDisk",
		Version:   meta.Version("beta"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "beta", "Instances")

	call := g.s.Beta.Instances.DetachDisk(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// AlphaInstances is an interface that allows for mocking of Instances.
type AlphaInstances interface {
	Get(ctx context.Context, key meta.Key) (*alpha.Instance, error)
	List(ctx context.Context, zone string) ([]*alpha.Instance, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.Instance) error
	Delete(ctx context.Context, key meta.Key) error

	AttachDisk(context.Context, meta.Key, *alpha.AttachedDisk) error
	DetachDisk(context.Context, meta.Key, string) error
	UpdateNetworkInterface(context.Context, meta.Key, string, *alpha.NetworkInterface) error
}

// NewMockAlphaInstances returns a new mock for Instances.
func NewMockAlphaInstances() *MockAlphaInstances {
	mock := &MockAlphaInstances{
		Objects:     map[meta.Key]*alpha.Instance{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaInstances is the mock for Instances.
type MockAlphaInstances struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.Instance

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaInstances, ctx context.Context, key meta.Key) (bool, *alpha.Instance, error)
	ListHook   func(m *MockAlphaInstances, ctx context.Context) (bool, []*alpha.Instance, error)
	InsertHook func(m *MockAlphaInstances, ctx context.Context, key meta.Key, obj *alpha.Instance) (bool, error)
	DeleteHook func(m *MockAlphaInstances, ctx context.Context, key meta.Key) (bool, error)

	AttachDiskHook             func(*MockAlphaInstances, context.Context, meta.Key, *alpha.AttachedDisk) error
	DetachDiskHook             func(*MockAlphaInstances, context.Context, meta.Key, string) error
	UpdateNetworkInterfaceHook func(*MockAlphaInstances, context.Context, meta.Key, string, *alpha.NetworkInterface) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaInstances) Get(ctx context.Context, key meta.Key) (*alpha.Instance, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaInstances %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockAlphaInstances) List(ctx context.Context, zone string) ([]*alpha.Instance, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.Instance
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaInstances) Insert(ctx context.Context, key meta.Key, obj *alpha.Instance) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaInstances %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaInstances) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaInstances %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockAlphaInstances) AttachDisk(ctx context.Context, key meta.Key, arg0 *alpha.AttachedDisk) error {

	if m.AttachDiskHook != nil {
		return m.AttachDiskHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockAlphaInstances) DetachDisk(ctx context.Context, key meta.Key, arg0 string) error {

	if m.DetachDiskHook != nil {
		return m.DetachDiskHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockAlphaInstances) UpdateNetworkInterface(ctx context.Context, key meta.Key, arg0 string, arg1 *alpha.NetworkInterface) error {

	if m.UpdateNetworkInterfaceHook != nil {
		return m.UpdateNetworkInterfaceHook(m, ctx, key, arg0, arg1)
	}
	return nil
}

// GCEAlphaInstances is a simplifying adapter for the GCE Instances.
type GCEAlphaInstances struct {
	s *Service
}

// Get the Instance named by key.
func (g *GCEAlphaInstances) Get(ctx context.Context, key meta.Key) (*alpha.Instance, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")

	call := g.s.Alpha.Instances.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Instance objects.
func (g *GCEAlphaInstances) List(ctx context.Context, zone string) ([]*alpha.Instance, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")

	call := g.s.Alpha.Instances.List(projectID, zone)

	var all []*alpha.Instance
	f := func(l *alpha.InstanceList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Instance with key of value obj.
func (g *GCEAlphaInstances) Insert(ctx context.Context, key meta.Key, obj *alpha.Instance) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")
	obj.Name = key.Name

	call := g.s.Alpha.Instances.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Instance referenced by key.
func (g *GCEAlphaInstances) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")

	call := g.s.Alpha.Instances.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEAlphaInstances) AttachDisk(ctx context.Context, key meta.Key, arg0 *alpha.AttachedDisk) error {
	rk := &RateLimitKey{
		Operation: "AttachDisk",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")

	call := g.s.Alpha.Instances.AttachDisk(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCEAlphaInstances) DetachDisk(ctx context.Context, key meta.Key, arg0 string) error {
	rk := &RateLimitKey{
		Operation: "DetachDisk",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")

	call := g.s.Alpha.Instances.DetachDisk(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCEAlphaInstances) UpdateNetworkInterface(ctx context.Context, key meta.Key, arg0 string, arg1 *alpha.NetworkInterface) error {
	rk := &RateLimitKey{
		Operation: "UpdateNetworkInterface",
		Version:   meta.Version("alpha"),
		Target:    "Instance",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "Instances")

	call := g.s.Alpha.Instances.UpdateNetworkInterface(projectID, key.Zone, key.Name, arg0, arg1)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// AlphaNetworkEndpointGroups is an interface that allows for mocking of NetworkEndpointGroups.
type AlphaNetworkEndpointGroups interface {
	Get(ctx context.Context, key meta.Key) (*alpha.NetworkEndpointGroup, error)
	List(ctx context.Context, zone string) ([]*alpha.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key meta.Key, obj *alpha.NetworkEndpointGroup) error
	Delete(ctx context.Context, key meta.Key) error

	AttachNetworkEndpoints(context.Context, meta.Key, *alpha.NetworkEndpointGroupsAttachEndpointsRequest) error
	DetachNetworkEndpoints(context.Context, meta.Key, *alpha.NetworkEndpointGroupsDetachEndpointsRequest) error
}

// NewMockAlphaNetworkEndpointGroups returns a new mock for NetworkEndpointGroups.
func NewMockAlphaNetworkEndpointGroups() *MockAlphaNetworkEndpointGroups {
	mock := &MockAlphaNetworkEndpointGroups{
		Objects:     map[meta.Key]*alpha.NetworkEndpointGroup{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaNetworkEndpointGroups is the mock for NetworkEndpointGroups.
type MockAlphaNetworkEndpointGroups struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*alpha.NetworkEndpointGroup

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockAlphaNetworkEndpointGroups, ctx context.Context, key meta.Key) (bool, *alpha.NetworkEndpointGroup, error)
	ListHook   func(m *MockAlphaNetworkEndpointGroups, ctx context.Context) (bool, []*alpha.NetworkEndpointGroup, error)
	InsertHook func(m *MockAlphaNetworkEndpointGroups, ctx context.Context, key meta.Key, obj *alpha.NetworkEndpointGroup) (bool, error)
	DeleteHook func(m *MockAlphaNetworkEndpointGroups, ctx context.Context, key meta.Key) (bool, error)

	AttachNetworkEndpointsHook func(*MockAlphaNetworkEndpointGroups, context.Context, meta.Key, *alpha.NetworkEndpointGroupsAttachEndpointsRequest) error
	DetachNetworkEndpointsHook func(*MockAlphaNetworkEndpointGroups, context.Context, meta.Key, *alpha.NetworkEndpointGroupsDetachEndpointsRequest) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaNetworkEndpointGroups) Get(ctx context.Context, key meta.Key) (*alpha.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaNetworkEndpointGroups %v not found", key),
	}
}

// List all of the objects in the mock in the given zone.
func (m *MockAlphaNetworkEndpointGroups) List(ctx context.Context, zone string) ([]*alpha.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*alpha.NetworkEndpointGroup
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaNetworkEndpointGroups) Insert(ctx context.Context, key meta.Key, obj *alpha.NetworkEndpointGroup) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaNetworkEndpointGroups %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaNetworkEndpointGroups) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaNetworkEndpointGroups %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockAlphaNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key meta.Key, arg0 *alpha.NetworkEndpointGroupsAttachEndpointsRequest) error {

	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockAlphaNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key meta.Key, arg0 *alpha.NetworkEndpointGroupsDetachEndpointsRequest) error {

	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEAlphaNetworkEndpointGroups is a simplifying adapter for the GCE NetworkEndpointGroups.
type GCEAlphaNetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCEAlphaNetworkEndpointGroups) Get(ctx context.Context, key meta.Key) (*alpha.NetworkEndpointGroup, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Target:    "NetworkEndpointGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "NetworkEndpointGroups")

	call := g.s.Alpha.NetworkEndpointGroups.Get(projectID, key.Zone, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all NetworkEndpointGroup objects.
func (g *GCEAlphaNetworkEndpointGroups) List(ctx context.Context, zone string) ([]*alpha.NetworkEndpointGroup, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("alpha"),
		Target:    "NetworkEndpointGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "NetworkEndpointGroups")

	call := g.s.Alpha.NetworkEndpointGroups.List(projectID, zone)

	var all []*alpha.NetworkEndpointGroup
	f := func(l *alpha.NetworkEndpointGroupList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCEAlphaNetworkEndpointGroups) Insert(ctx context.Context, key meta.Key, obj *alpha.NetworkEndpointGroup) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Target:    "NetworkEndpointGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "NetworkEndpointGroups")
	obj.Name = key.Name

	call := g.s.Alpha.NetworkEndpointGroups.Insert(projectID, key.Zone, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCEAlphaNetworkEndpointGroups) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Target:    "NetworkEndpointGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "NetworkEndpointGroups")

	call := g.s.Alpha.NetworkEndpointGroups.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEAlphaNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key meta.Key, arg0 *alpha.NetworkEndpointGroupsAttachEndpointsRequest) error {
	rk := &RateLimitKey{
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Target:    "NetworkEndpointGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "NetworkEndpointGroups")

	call := g.s.Alpha.NetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCEAlphaNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key meta.Key, arg0 *alpha.NetworkEndpointGroupsDetachEndpointsRequest) error {
	rk := &RateLimitKey{
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Target:    "NetworkEndpointGroup",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "alpha", "NetworkEndpointGroups")

	call := g.s.Alpha.NetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// Regions is an interface that allows for mocking of Regions.
type Regions interface {
	Get(ctx context.Context, key meta.Key) (*ga.Region, error)
	List(ctx context.Context) ([]*ga.Region, error)
}

// NewMockRegions returns a new mock for Regions.
func NewMockRegions() *MockRegions {
	mock := &MockRegions{
		Objects:     map[meta.Key]*ga.Region{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegions is the mock for Regions.
type MockRegions struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Region

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockRegions, ctx context.Context, key meta.Key) (bool, *ga.Region, error)
	ListHook   func(m *MockRegions, ctx context.Context) (bool, []*ga.Region, error)
	InsertHook func(m *MockRegions, ctx context.Context, key meta.Key, obj *ga.Region) (bool, error)
	DeleteHook func(m *MockRegions, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegions) Get(ctx context.Context, key meta.Key) (*ga.Region, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegions %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockRegions) List(ctx context.Context) ([]*ga.Region, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Region
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// GCERegions is a simplifying adapter for the GCE Regions.
type GCERegions struct {
	s *Service
}

// Get the Region named by key.
func (g *GCERegions) Get(ctx context.Context, key meta.Key) (*ga.Region, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Region",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Regions")

	call := g.s.GA.Regions.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Region objects.
func (g *GCERegions) List(ctx context.Context) ([]*ga.Region, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Region",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Regions")

	call := g.s.GA.Regions.List(projectID)

	var all []*ga.Region
	f := func(l *ga.RegionList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Routes is an interface that allows for mocking of Routes.
type Routes interface {
	Get(ctx context.Context, key meta.Key) (*ga.Route, error)
	List(ctx context.Context) ([]*ga.Route, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.Route) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockRoutes returns a new mock for Routes.
func NewMockRoutes() *MockRoutes {
	mock := &MockRoutes{
		Objects:     map[meta.Key]*ga.Route{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRoutes is the mock for Routes.
type MockRoutes struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Route

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockRoutes, ctx context.Context, key meta.Key) (bool, *ga.Route, error)
	ListHook   func(m *MockRoutes, ctx context.Context) (bool, []*ga.Route, error)
	InsertHook func(m *MockRoutes, ctx context.Context, key meta.Key, obj *ga.Route) (bool, error)
	DeleteHook func(m *MockRoutes, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRoutes) Get(ctx context.Context, key meta.Key) (*ga.Route, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRoutes %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockRoutes) List(ctx context.Context) ([]*ga.Route, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Route
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRoutes) Insert(ctx context.Context, key meta.Key, obj *ga.Route) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRoutes %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRoutes) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRoutes %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCERoutes is a simplifying adapter for the GCE Routes.
type GCERoutes struct {
	s *Service
}

// Get the Route named by key.
func (g *GCERoutes) Get(ctx context.Context, key meta.Key) (*ga.Route, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Route",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Routes")

	call := g.s.GA.Routes.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Route objects.
func (g *GCERoutes) List(ctx context.Context) ([]*ga.Route, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Route",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Routes")

	call := g.s.GA.Routes.List(projectID)

	var all []*ga.Route
	f := func(l *ga.RouteList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert Route with key of value obj.
func (g *GCERoutes) Insert(ctx context.Context, key meta.Key, obj *ga.Route) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "Route",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Routes")
	obj.Name = key.Name

	call := g.s.GA.Routes.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the Route referenced by key.
func (g *GCERoutes) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "Route",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Routes")

	call := g.s.GA.Routes.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// SslCertificates is an interface that allows for mocking of SslCertificates.
type SslCertificates interface {
	Get(ctx context.Context, key meta.Key) (*ga.SslCertificate, error)
	List(ctx context.Context) ([]*ga.SslCertificate, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.SslCertificate) error
	Delete(ctx context.Context, key meta.Key) error
}

// NewMockSslCertificates returns a new mock for SslCertificates.
func NewMockSslCertificates() *MockSslCertificates {
	mock := &MockSslCertificates{
		Objects:     map[meta.Key]*ga.SslCertificate{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockSslCertificates is the mock for SslCertificates.
type MockSslCertificates struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.SslCertificate

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockSslCertificates, ctx context.Context, key meta.Key) (bool, *ga.SslCertificate, error)
	ListHook   func(m *MockSslCertificates, ctx context.Context) (bool, []*ga.SslCertificate, error)
	InsertHook func(m *MockSslCertificates, ctx context.Context, key meta.Key, obj *ga.SslCertificate) (bool, error)
	DeleteHook func(m *MockSslCertificates, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockSslCertificates) Get(ctx context.Context, key meta.Key) (*ga.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockSslCertificates %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockSslCertificates) List(ctx context.Context) ([]*ga.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.SslCertificate
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockSslCertificates) Insert(ctx context.Context, key meta.Key, obj *ga.SslCertificate) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockSslCertificates %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockSslCertificates) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockSslCertificates %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

// GCESslCertificates is a simplifying adapter for the GCE SslCertificates.
type GCESslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCESslCertificates) Get(ctx context.Context, key meta.Key) (*ga.SslCertificate, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "SslCertificate",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "SslCertificates")

	call := g.s.GA.SslCertificates.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all SslCertificate objects.
func (g *GCESslCertificates) List(ctx context.Context) ([]*ga.SslCertificate, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "SslCertificate",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "SslCertificates")

	call := g.s.GA.SslCertificates.List(projectID)

	var all []*ga.SslCertificate
	f := func(l *ga.SslCertificateList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCESslCertificates) Insert(ctx context.Context, key meta.Key, obj *ga.SslCertificate) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "SslCertificate",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "SslCertificates")
	obj.Name = key.Name

	call := g.s.GA.SslCertificates.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the SslCertificate referenced by key.
func (g *GCESslCertificates) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "SslCertificate",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "SslCertificates")

	call := g.s.GA.SslCertificates.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// TargetHttpProxies is an interface that allows for mocking of TargetHttpProxies.
type TargetHttpProxies interface {
	Get(ctx context.Context, key meta.Key) (*ga.TargetHttpProxy, error)
	List(ctx context.Context) ([]*ga.TargetHttpProxy, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.TargetHttpProxy) error
	Delete(ctx context.Context, key meta.Key) error

	SetUrlMap(context.Context, meta.Key, *ga.UrlMapReference) error
}

// NewMockTargetHttpProxies returns a new mock for TargetHttpProxies.
func NewMockTargetHttpProxies() *MockTargetHttpProxies {
	mock := &MockTargetHttpProxies{
		Objects:     map[meta.Key]*ga.TargetHttpProxy{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetHttpProxies is the mock for TargetHttpProxies.
type MockTargetHttpProxies struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.TargetHttpProxy

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockTargetHttpProxies, ctx context.Context, key meta.Key) (bool, *ga.TargetHttpProxy, error)
	ListHook   func(m *MockTargetHttpProxies, ctx context.Context) (bool, []*ga.TargetHttpProxy, error)
	InsertHook func(m *MockTargetHttpProxies, ctx context.Context, key meta.Key, obj *ga.TargetHttpProxy) (bool, error)
	DeleteHook func(m *MockTargetHttpProxies, ctx context.Context, key meta.Key) (bool, error)

	SetUrlMapHook func(*MockTargetHttpProxies, context.Context, meta.Key, *ga.UrlMapReference) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetHttpProxies) Get(ctx context.Context, key meta.Key) (*ga.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetHttpProxies %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockTargetHttpProxies) List(ctx context.Context) ([]*ga.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.TargetHttpProxy
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetHttpProxies) Insert(ctx context.Context, key meta.Key, obj *ga.TargetHttpProxy) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetHttpProxies %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetHttpProxies) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetHttpProxies %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockTargetHttpProxies) SetUrlMap(ctx context.Context, key meta.Key, arg0 *ga.UrlMapReference) error {

	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(m, ctx, key, arg0)
	}
	return nil
}

// GCETargetHttpProxies is a simplifying adapter for the GCE TargetHttpProxies.
type GCETargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCETargetHttpProxies) Get(ctx context.Context, key meta.Key) (*ga.TargetHttpProxy, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpProxies")

	call := g.s.GA.TargetHttpProxies.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all TargetHttpProxy objects.
func (g *GCETargetHttpProxies) List(ctx context.Context) ([]*ga.TargetHttpProxy, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpProxies")

	call := g.s.GA.TargetHttpProxies.List(projectID)

	var all []*ga.TargetHttpProxy
	f := func(l *ga.TargetHttpProxyList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCETargetHttpProxies) Insert(ctx context.Context, key meta.Key, obj *ga.TargetHttpProxy) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpProxies")
	obj.Name = key.Name

	call := g.s.GA.TargetHttpProxies.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCETargetHttpProxies) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpProxies")

	call := g.s.GA.TargetHttpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCETargetHttpProxies) SetUrlMap(ctx context.Context, key meta.Key, arg0 *ga.UrlMapReference) error {
	rk := &RateLimitKey{
		Operation: "SetUrlMap",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpProxies")

	call := g.s.GA.TargetHttpProxies.SetUrlMap(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// TargetHttpsProxies is an interface that allows for mocking of TargetHttpsProxies.
type TargetHttpsProxies interface {
	Get(ctx context.Context, key meta.Key) (*ga.TargetHttpsProxy, error)
	List(ctx context.Context) ([]*ga.TargetHttpsProxy, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.TargetHttpsProxy) error
	Delete(ctx context.Context, key meta.Key) error

	SetSslCertificates(context.Context, meta.Key, *ga.TargetHttpsProxiesSetSslCertificatesRequest) error
	SetUrlMap(context.Context, meta.Key, *ga.UrlMapReference) error
}

// NewMockTargetHttpsProxies returns a new mock for TargetHttpsProxies.
func NewMockTargetHttpsProxies() *MockTargetHttpsProxies {
	mock := &MockTargetHttpsProxies{
		Objects:     map[meta.Key]*ga.TargetHttpsProxy{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetHttpsProxies is the mock for TargetHttpsProxies.
type MockTargetHttpsProxies struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.TargetHttpsProxy

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockTargetHttpsProxies, ctx context.Context, key meta.Key) (bool, *ga.TargetHttpsProxy, error)
	ListHook   func(m *MockTargetHttpsProxies, ctx context.Context) (bool, []*ga.TargetHttpsProxy, error)
	InsertHook func(m *MockTargetHttpsProxies, ctx context.Context, key meta.Key, obj *ga.TargetHttpsProxy) (bool, error)
	DeleteHook func(m *MockTargetHttpsProxies, ctx context.Context, key meta.Key) (bool, error)

	SetSslCertificatesHook func(*MockTargetHttpsProxies, context.Context, meta.Key, *ga.TargetHttpsProxiesSetSslCertificatesRequest) error
	SetUrlMapHook          func(*MockTargetHttpsProxies, context.Context, meta.Key, *ga.UrlMapReference) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetHttpsProxies) Get(ctx context.Context, key meta.Key) (*ga.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetHttpsProxies %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockTargetHttpsProxies) List(ctx context.Context) ([]*ga.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.TargetHttpsProxy
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetHttpsProxies) Insert(ctx context.Context, key meta.Key, obj *ga.TargetHttpsProxy) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetHttpsProxies %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetHttpsProxies) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetHttpsProxies %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockTargetHttpsProxies) SetSslCertificates(ctx context.Context, key meta.Key, arg0 *ga.TargetHttpsProxiesSetSslCertificatesRequest) error {

	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockTargetHttpsProxies) SetUrlMap(ctx context.Context, key meta.Key, arg0 *ga.UrlMapReference) error {

	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(m, ctx, key, arg0)
	}
	return nil
}

// GCETargetHttpsProxies is a simplifying adapter for the GCE TargetHttpsProxies.
type GCETargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCETargetHttpsProxies) Get(ctx context.Context, key meta.Key) (*ga.TargetHttpsProxy, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpsProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpsProxies")

	call := g.s.GA.TargetHttpsProxies.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all TargetHttpsProxy objects.
func (g *GCETargetHttpsProxies) List(ctx context.Context) ([]*ga.TargetHttpsProxy, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpsProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpsProxies")

	call := g.s.GA.TargetHttpsProxies.List(projectID)

	var all []*ga.TargetHttpsProxy
	f := func(l *ga.TargetHttpsProxyList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCETargetHttpsProxies) Insert(ctx context.Context, key meta.Key, obj *ga.TargetHttpsProxy) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpsProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpsProxies")
	obj.Name = key.Name

	call := g.s.GA.TargetHttpsProxies.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCETargetHttpsProxies) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpsProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpsProxies")

	call := g.s.GA.TargetHttpsProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCETargetHttpsProxies) SetSslCertificates(ctx context.Context, key meta.Key, arg0 *ga.TargetHttpsProxiesSetSslCertificatesRequest) error {
	rk := &RateLimitKey{
		Operation: "SetSslCertificates",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpsProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpsProxies")

	call := g.s.GA.TargetHttpsProxies.SetSslCertificates(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCETargetHttpsProxies) SetUrlMap(ctx context.Context, key meta.Key, arg0 *ga.UrlMapReference) error {
	rk := &RateLimitKey{
		Operation: "SetUrlMap",
		Version:   meta.Version("ga"),
		Target:    "TargetHttpsProxy",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetHttpsProxies")

	call := g.s.GA.TargetHttpsProxies.SetUrlMap(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// TargetPools is an interface that allows for mocking of TargetPools.
type TargetPools interface {
	Get(ctx context.Context, key meta.Key) (*ga.TargetPool, error)
	List(ctx context.Context, region string) ([]*ga.TargetPool, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.TargetPool) error
	Delete(ctx context.Context, key meta.Key) error

	AddInstance(context.Context, meta.Key, *ga.TargetPoolsAddInstanceRequest) error
	RemoveInstance(context.Context, meta.Key, *ga.TargetPoolsRemoveInstanceRequest) error
}

// NewMockTargetPools returns a new mock for TargetPools.
func NewMockTargetPools() *MockTargetPools {
	mock := &MockTargetPools{
		Objects:     map[meta.Key]*ga.TargetPool{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetPools is the mock for TargetPools.
type MockTargetPools struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.TargetPool

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockTargetPools, ctx context.Context, key meta.Key) (bool, *ga.TargetPool, error)
	ListHook   func(m *MockTargetPools, ctx context.Context) (bool, []*ga.TargetPool, error)
	InsertHook func(m *MockTargetPools, ctx context.Context, key meta.Key, obj *ga.TargetPool) (bool, error)
	DeleteHook func(m *MockTargetPools, ctx context.Context, key meta.Key) (bool, error)

	AddInstanceHook    func(*MockTargetPools, context.Context, meta.Key, *ga.TargetPoolsAddInstanceRequest) error
	RemoveInstanceHook func(*MockTargetPools, context.Context, meta.Key, *ga.TargetPoolsRemoveInstanceRequest) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetPools) Get(ctx context.Context, key meta.Key) (*ga.TargetPool, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetPools %v not found", key),
	}
}

// List all of the objects in the mock in the given region.
func (m *MockTargetPools) List(ctx context.Context, region string) ([]*ga.TargetPool, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.TargetPool
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}

		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetPools) Insert(ctx context.Context, key meta.Key, obj *ga.TargetPool) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetPools %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetPools) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetPools %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockTargetPools) AddInstance(ctx context.Context, key meta.Key, arg0 *ga.TargetPoolsAddInstanceRequest) error {

	if m.AddInstanceHook != nil {
		return m.AddInstanceHook(m, ctx, key, arg0)
	}
	return nil
}

func (m *MockTargetPools) RemoveInstance(ctx context.Context, key meta.Key, arg0 *ga.TargetPoolsRemoveInstanceRequest) error {

	if m.RemoveInstanceHook != nil {
		return m.RemoveInstanceHook(m, ctx, key, arg0)
	}
	return nil
}

// GCETargetPools is a simplifying adapter for the GCE TargetPools.
type GCETargetPools struct {
	s *Service
}

// Get the TargetPool named by key.
func (g *GCETargetPools) Get(ctx context.Context, key meta.Key) (*ga.TargetPool, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "TargetPool",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetPools")

	call := g.s.GA.TargetPools.Get(projectID, key.Region, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all TargetPool objects.
func (g *GCETargetPools) List(ctx context.Context, region string) ([]*ga.TargetPool, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "TargetPool",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetPools")

	call := g.s.GA.TargetPools.List(projectID, region)

	var all []*ga.TargetPool
	f := func(l *ga.TargetPoolList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert TargetPool with key of value obj.
func (g *GCETargetPools) Insert(ctx context.Context, key meta.Key, obj *ga.TargetPool) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "TargetPool",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetPools")
	obj.Name = key.Name

	call := g.s.GA.TargetPools.Insert(projectID, key.Region, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the TargetPool referenced by key.
func (g *GCETargetPools) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "TargetPool",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetPools")

	call := g.s.GA.TargetPools.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCETargetPools) AddInstance(ctx context.Context, key meta.Key, arg0 *ga.TargetPoolsAddInstanceRequest) error {
	rk := &RateLimitKey{
		Operation: "AddInstance",
		Version:   meta.Version("ga"),
		Target:    "TargetPool",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetPools")

	call := g.s.GA.TargetPools.AddInstance(projectID, key.Region, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

func (g *GCETargetPools) RemoveInstance(ctx context.Context, key meta.Key, arg0 *ga.TargetPoolsRemoveInstanceRequest) error {
	rk := &RateLimitKey{
		Operation: "RemoveInstance",
		Version:   meta.Version("ga"),
		Target:    "TargetPool",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "TargetPools")

	call := g.s.GA.TargetPools.RemoveInstance(projectID, key.Region, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// UrlMaps is an interface that allows for mocking of UrlMaps.
type UrlMaps interface {
	Get(ctx context.Context, key meta.Key) (*ga.UrlMap, error)
	List(ctx context.Context) ([]*ga.UrlMap, error)
	Insert(ctx context.Context, key meta.Key, obj *ga.UrlMap) error
	Delete(ctx context.Context, key meta.Key) error

	Update(context.Context, meta.Key, *ga.UrlMap) error
}

// NewMockUrlMaps returns a new mock for UrlMaps.
func NewMockUrlMaps() *MockUrlMaps {
	mock := &MockUrlMaps{
		Objects:     map[meta.Key]*ga.UrlMap{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockUrlMaps is the mock for UrlMaps.
type MockUrlMaps struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.UrlMap

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockUrlMaps, ctx context.Context, key meta.Key) (bool, *ga.UrlMap, error)
	ListHook   func(m *MockUrlMaps, ctx context.Context) (bool, []*ga.UrlMap, error)
	InsertHook func(m *MockUrlMaps, ctx context.Context, key meta.Key, obj *ga.UrlMap) (bool, error)
	DeleteHook func(m *MockUrlMaps, ctx context.Context, key meta.Key) (bool, error)

	UpdateHook func(*MockUrlMaps, context.Context, meta.Key, *ga.UrlMap) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockUrlMaps) Get(ctx context.Context, key meta.Key) (*ga.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockUrlMaps %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockUrlMaps) List(ctx context.Context) ([]*ga.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.UrlMap
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockUrlMaps) Insert(ctx context.Context, key meta.Key, obj *ga.UrlMap) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(m, ctx, key, obj); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; ok {
		return &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockUrlMaps %v exists", key),
		}
	}

	m.Objects[key] = obj
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockUrlMaps) Delete(ctx context.Context, key meta.Key) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(m, ctx, key); intercept {
			return err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[key]; ok {
		return err
	}
	if _, ok := m.Objects[key]; !ok {
		return &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockUrlMaps %v not found", key),
		}
	}

	delete(m.Objects, key)
	return nil
}

func (m *MockUrlMaps) Update(ctx context.Context, key meta.Key, arg0 *ga.UrlMap) error {

	if m.UpdateHook != nil {
		return m.UpdateHook(m, ctx, key, arg0)
	}
	return nil
}

// GCEUrlMaps is a simplifying adapter for the GCE UrlMaps.
type GCEUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCEUrlMaps) Get(ctx context.Context, key meta.Key) (*ga.UrlMap, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "UrlMap",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "UrlMaps")

	call := g.s.GA.UrlMaps.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all UrlMap objects.
func (g *GCEUrlMaps) List(ctx context.Context) ([]*ga.UrlMap, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "UrlMap",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "UrlMaps")

	call := g.s.GA.UrlMaps.List(projectID)

	var all []*ga.UrlMap
	f := func(l *ga.UrlMapList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCEUrlMaps) Insert(ctx context.Context, key meta.Key, obj *ga.UrlMap) error {
	rk := &RateLimitKey{
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Target:    "UrlMap",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "UrlMaps")
	obj.Name = key.Name

	call := g.s.GA.UrlMaps.Insert(projectID, obj)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

// Delete the UrlMap referenced by key.
func (g *GCEUrlMaps) Delete(ctx context.Context, key meta.Key) error {
	rk := &RateLimitKey{
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Target:    "UrlMap",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "UrlMaps")

	call := g.s.GA.UrlMaps.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)
}

func (g *GCEUrlMaps) Update(ctx context.Context, key meta.Key, arg0 *ga.UrlMap) error {
	rk := &RateLimitKey{
		Operation: "Update",
		Version:   meta.Version("ga"),
		Target:    "UrlMap",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "UrlMaps")

	call := g.s.GA.UrlMaps.Update(projectID, key.Name, arg0)

	call.Context(ctx)

	op, err := call.Do()
	if err != nil {
		return err
	}
	return g.s.WaitForCompletion(ctx, op)

}

// Zones is an interface that allows for mocking of Zones.
type Zones interface {
	Get(ctx context.Context, key meta.Key) (*ga.Zone, error)
	List(ctx context.Context) ([]*ga.Zone, error)
}

// NewMockZones returns a new mock for Zones.
func NewMockZones() *MockZones {
	mock := &MockZones{
		Objects:     map[meta.Key]*ga.Zone{},
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockZones is the mock for Zones.
type MockZones struct {
	Lock sync.Mutex

	// Objects maintained by the mock.
	Objects map[meta.Key]*ga.Zone

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// GetHook, ListHook, InsertHook, DeleteHook allow you to intercept the
	// standard processing of the mock in order to add your own logic.
	// Return (true, _, _) to prevent the normal execution flow of the
	// mock. Return (false, nil, nil) to continue with normal mock behavior
	// after the hook function executes.
	GetHook    func(m *MockZones, ctx context.Context, key meta.Key) (bool, *ga.Zone, error)
	ListHook   func(m *MockZones, ctx context.Context) (bool, []*ga.Zone, error)
	InsertHook func(m *MockZones, ctx context.Context, key meta.Key, obj *ga.Zone) (bool, error)
	DeleteHook func(m *MockZones, ctx context.Context, key meta.Key) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockZones) Get(ctx context.Context, key meta.Key) (*ga.Zone, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(m, ctx, key); intercept {
			return obj, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[key]; ok {
		return nil, err
	}
	if obj, ok := m.Objects[key]; ok {
		return obj, nil
	}
	return nil, &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockZones %v not found", key),
	}
}

// List all of the objects in the mock.
func (m *MockZones) List(ctx context.Context) ([]*ga.Zone, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(m, ctx); intercept {
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		return nil, *m.ListError
	}

	var objs []*ga.Zone
	for _, obj := range m.Objects {
		objs = append(objs, obj)
	}

	return objs, nil
}

// GCEZones is a simplifying adapter for the GCE Zones.
type GCEZones struct {
	s *Service
}

// Get the Zone named by key.
func (g *GCEZones) Get(ctx context.Context, key meta.Key) (*ga.Zone, error) {
	rk := &RateLimitKey{
		Operation: "Get",
		Version:   meta.Version("ga"),
		Target:    "Zone",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Zones")

	call := g.s.GA.Zones.Get(projectID, key.Name)

	call.Context(ctx)

	return call.Do()
}

// List all Zone objects.
func (g *GCEZones) List(ctx context.Context) ([]*ga.Zone, error) {
	rk := &RateLimitKey{
		Operation: "List",
		Version:   meta.Version("ga"),
		Target:    "Zone",
	}
	g.s.RateLimiter.Accept(ctx, rk)
	projectID := g.s.ProjectRouter.ProjectID(ctx, "ga", "Zones")

	call := g.s.GA.Zones.List(projectID)

	var all []*ga.Zone
	f := func(l *ga.ZoneList) error {
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		return nil, err
	}
	return all, nil
}
